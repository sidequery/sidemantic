[
  {
    "objectID": "marimo-interactive.html",
    "href": "marimo-interactive.html",
    "title": "Interactive Notebook",
    "section": "",
    "text": "Use Sidemantic’s semantic layer directly in the browser. This demo:\n\nDefines semantic models (orders, customers, region_map) with dimensions and metrics (including ratio metric return_rate).\nUses reusable segments (named filters) and metric-level filters that auto-apply in WHERE clauses.\nDeclares relationships (many_to_one, one_to_many) with automatic join-path discovery for multi-hop queries (e.g., region_group × tier).\nCompiles metrics + dimensions + filters to SQL (DuckDB dialect) via the Sidemantic SQL generator.\nApplies global filters (status, region, category, tier) that propagate across models; period-to-date metrics are computed by filtering time.\nShows an ER diagram generated from the semantic graph to explain relationships.\n\n\n    \n    \n    \n    import%20micropip%0Atry%3A%0A%20%20%20%20import%20sidemantic%20%20%23%20type%3A%20ignore%0Aexcept%20ModuleNotFoundError%3A%0A%20%20%20%20await%20micropip.install(%5B%22sidemantic%3D%3D0.2.3%22%5D%2C%20deps%3DFalse)%0A%20%20%20%20import%20sidemantic%20%20%23%20type%3A%20ignore\n\n\n    \n    \n    \n    import%20marimo%20as%20mo\n\n\n    \n    &lt;_duckdb.DuckDBPyConnection object at 0x105933d30&gt;\n    \n    import%20altair%20as%20alt%0Aimport%20duckdb%0A%0Amo.md(%22%23%20Sidemantic%20Interactive%20Demo%22)%0Aconn%20%3D%20duckdb.connect(%22%3Amemory%3A%22)%0A%0AN%20%3D%2020000%0Asql_create_orders%20%3D%20f%22%22%22%0ACREATE%20OR%20REPLACE%20TABLE%20orders%20AS%0ASELECT%0A%20%20range%20AS%20id%2C%0A%20%201%20%2B%20CAST(random()*500%20AS%20INTEGER)%20AS%20customer_id%2C%0A%20%20CASE%0A%20%20%20%20WHEN%20random()%20%3C%200.50%20THEN%20'completed'%0A%20%20%20%20WHEN%20random()%20%3C%200.70%20THEN%20'shipped'%0A%20%20%20%20WHEN%20random()%20%3C%200.85%20THEN%20'pending'%0A%20%20%20%20WHEN%20random()%20%3C%200.95%20THEN%20'cancelled'%0A%20%20%20%20ELSE%20'returned'%0A%20%20END%20AS%20status%2C%0A%20%20(DATE%20'2024-01-01'%20%2B%20CAST(random()*365%20AS%20INTEGER))%20AS%20order_date%2C%0A%20%20ROUND((random()*600)%2B10%2C2)%20AS%20amount%2C%0A%20%20CASE%20WHEN%20random()%20%3C%200.50%20THEN%20'US'%20WHEN%20random()%20%3C%200.80%20THEN%20'EU'%20ELSE%20'APAC'%20END%20AS%20region%2C%0A%20%20CASE%0A%20%20%20%20WHEN%20random()%20%3C%200.22%20THEN%20'electronics'%0A%20%20%20%20WHEN%20random()%20%3C%200.40%20THEN%20'apparel'%0A%20%20%20%20WHEN%20random()%20%3C%200.60%20THEN%20'home'%0A%20%20%20%20WHEN%20random()%20%3C%200.75%20THEN%20'toys'%0A%20%20%20%20WHEN%20random()%20%3C%200.88%20THEN%20'beauty'%0A%20%20%20%20ELSE%20'outdoors'%0A%20%20END%20AS%20category%0AFROM%20range(1%2C%20%7BN%7D)%3B%0A%22%22%22%0Aconn.execute(sql_create_orders)%0A%0Aconn.execute(%22%22%22%0AALTER%20TABLE%20orders%20ADD%20COLUMN%20order_month%20DATE%3B%0AUPDATE%20orders%20SET%20order_month%20%3D%20DATE_TRUNC('month'%2C%20order_date)%3B%0AALTER%20TABLE%20orders%20ADD%20COLUMN%20cost%20DOUBLE%3B%0AALTER%20TABLE%20orders%20ADD%20COLUMN%20profit%20DOUBLE%3B%0AUPDATE%20orders%20SET%20cost%20%3D%20ROUND(amount%20*%20(0.55%20%2B%20random()*0.30)%2C%202)%3B%0AUPDATE%20orders%20SET%20profit%20%3D%20ROUND(amount%20-%20cost%2C%202)%3B%0A%22%22%22)%0A%0Aconn.execute(%22%22%22%0ACREATE%20OR%20REPLACE%20TABLE%20customers%20AS%0ASELECT%0A%20%20range%20AS%20id%2C%0A%20%20CASE%20WHEN%20random()%20%3C%200.30%20THEN%20'premium'%20ELSE%20'standard'%20END%20AS%20tier%2C%0A%20%20CASE%20WHEN%20random()%20%3C%200.50%20THEN%20'US'%20WHEN%20random()%20%3C%200.80%20THEN%20'EU'%20ELSE%20'APAC'%20END%20AS%20region%0AFROM%20range(1%2C%20501)%3B%0A%22%22%22)%0A%0Aconn.execute(%22%22%22%0ACREATE%20OR%20REPLACE%20TABLE%20region_map(region%20VARCHAR%2C%20region_group%20VARCHAR)%3B%0AINSERT%20INTO%20region_map%20VALUES%20('US'%2C'Americas')%2C%20('EU'%2C'Europe')%2C%20('APAC'%2C'Asia%20Pacific')%3B%0A%22%22%22)\n\n\n    \n    \n    \n    %23%20Controls%20(multiselects)%0Astatus_opts%20%3D%20%5Br%5B0%5D%20for%20r%20in%20conn.execute(%22SELECT%20DISTINCT%20status%20FROM%20orders%20ORDER%20BY%201%22).fetchall()%5D%0Aregion_opts%20%3D%20%5Br%5B0%5D%20for%20r%20in%20conn.execute(%22SELECT%20DISTINCT%20region%20FROM%20orders%20ORDER%20BY%201%22).fetchall()%5D%0Acategory_opts%20%3D%20%5Br%5B0%5D%20for%20r%20in%20conn.execute(%22SELECT%20DISTINCT%20category%20FROM%20orders%20ORDER%20BY%201%22).fetchall()%5D%0Atier_opts%20%3D%20%5Br%5B0%5D%20for%20r%20in%20conn.execute(%22SELECT%20DISTINCT%20tier%20FROM%20customers%20ORDER%20BY%201%22).fetchall()%5D%0A%0Astatus_select%20%3D%20mo.ui.multiselect(options%3Dstatus_opts%2C%20value%3D%5B%5D%2C%20label%3D%22Status%22)%0Aregion_select%20%3D%20mo.ui.multiselect(options%3Dregion_opts%2C%20value%3D%5B%5D%2C%20label%3D%22Region%22)%0Acategory_select%20%3D%20mo.ui.multiselect(options%3Dcategory_opts%2C%20value%3D%5B%5D%2C%20label%3D%22Category%22)%0Atier_select%20%3D%20mo.ui.multiselect(options%3Dtier_opts%2C%20value%3D%5B%5D%2C%20label%3D%22Tier%22)%0Amonth_options%20%3D%20%5Br%5B0%5D%20for%20r%20in%20conn.execute(%22SELECT%20DISTINCT%20strftime(order_month%2C%20'%25Y-%25m')%20AS%20ym%20FROM%20orders%20ORDER%20BY%20ym%22).fetchall()%5D%0Amonth_select%20%3D%20mo.ui.dropdown(options%3Dmonth_options%2C%20value%3Dmonth_options%5B-1%5D%2C%20label%3D%22Month%20for%20*_TD%22)%0A%0A%23%20Render%20all%20controls%20together%20so%20they%20show%20reliably%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A12px%22%3E%3C%2Fdiv%3E')%2C%0A%20%20%20%20mo.hstack(%5Bstatus_select%2C%20region_select%2C%20category_select%5D)%2C%0A%20%20%20%20mo.hstack(%5Btier_select%2C%20month_select%5D)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A12px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)\n\n\n    \n    \n    \n    %23%20Build%20a%20minimal%20semantic%20model%20with%20Sidemantic%20(compile%20SQL%20and%20execute%20in%20DuckDB)%0Afrom%20importlib%20import%20import_module%0AModel%20%3D%20import_module(%22sidemantic.core.model%22).Model%0ADimension%20%3D%20import_module(%22sidemantic.core.dimension%22).Dimension%0AMetric%20%3D%20import_module(%22sidemantic.core.metric%22).Metric%0ARelationship%20%3D%20import_module(%22sidemantic.core.relationship%22).Relationship%0ASegment%20%3D%20import_module(%22sidemantic.core.segment%22).Segment%0ASemanticGraph%20%3D%20import_module(%22sidemantic.core.semantic_graph%22).SemanticGraph%0ASQLGenerator%20%3D%20import_module(%22sidemantic.sql.generator_v2%22).SQLGenerator%0A%0Agraph%20%3D%20SemanticGraph()%0A%0Aorders_model%20%3D%20Model(%0A%20%20%20%20name%3D%22orders%22%2C%0A%20%20%20%20table%3D%22orders%22%2C%0A%20%20%20%20primary_key%3D%22id%22%2C%0A%20%20%20%20dimensions%3D%5B%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22status%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22status%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22order_date%22%2C%20type%3D%22time%22%2C%20expr%3D%22order_date%22%2C%20granularity%3D%22day%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22region%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22region%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22category%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22category%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20metrics%3D%5B%0A%20%20%20%20%20%20%20%20Metric(name%3D%22revenue%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22amount%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22order_count%22%2C%20agg%3D%22count%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22avg_order_value%22%2C%20agg%3D%22avg%22%2C%20expr%3D%22amount%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22cost%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22cost%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22profit%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22profit%22)%2C%0A%20%20%20%20%20%20%20%20%23%20Metric%20with%20filter%20(auto-applied%20in%20WHERE%20clause)%0A%20%20%20%20%20%20%20%20Metric(name%3D%22returns%22%2C%20agg%3D%22count%22%2C%20filters%3D%5B%22%7Bmodel%7D.status%20%3D%20'returned'%22%5D)%2C%0A%20%20%20%20%20%20%20%20%23%20Ratio%20metric%0A%20%20%20%20%20%20%20%20Metric(name%3D%22return_rate%22%2C%20type%3D%22ratio%22%2C%20numerator%3D%22orders.returns%22%2C%20denominator%3D%22orders.order_count%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20segments%3D%5B%0A%20%20%20%20%20%20%20%20Segment(name%3D%22completed%22%2C%20sql%3D%22%7Bmodel%7D.status%20%3D%20'completed'%22)%2C%0A%20%20%20%20%20%20%20%20Segment(name%3D%22high_value%22%2C%20sql%3D%22%7Bmodel%7D.amount%20%3E%3D%20300%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20relationships%3D%5BRelationship(name%3D%22customers%22%2C%20type%3D%22many_to_one%22%2C%20foreign_key%3D%22customer_id%22)%5D%2C%0A)%0A%0Acustomers_model%20%3D%20Model(%0A%20%20%20%20name%3D%22customers%22%2C%0A%20%20%20%20table%3D%22customers%22%2C%0A%20%20%20%20primary_key%3D%22id%22%2C%0A%20%20%20%20dimensions%3D%5B%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22tier%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22tier%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22region%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22region%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20relationships%3D%5BRelationship(name%3D%22region_map%22%2C%20type%3D%22many_to_one%22%2C%20foreign_key%3D%22region%22%2C%20primary_key%3D%22region%22)%5D%2C%0A)%0A%0Aregion_map_model%20%3D%20Model(%0A%20%20%20%20name%3D%22region_map%22%2C%0A%20%20%20%20table%3D%22region_map%22%2C%0A%20%20%20%20primary_key%3D%22region%22%2C%0A%20%20%20%20dimensions%3D%5BDimension(name%3D%22region_group%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22region_group%22)%5D%2C%0A)%0A%0Agraph.add_model(orders_model)%0Agraph.add_model(customers_model)%0Agraph.add_model(region_map_model)%0A%0Agenerator%20%3D%20SQLGenerator(graph%2C%20dialect%3D%22duckdb%22)\n\n\n    \n    \n    \n    %23%20Helpers%3A%20build%20Sidemantic%20filters%20and%20run%20compiled%20SQL%20in%20DuckDB%0Adef%20build_filters()%3A%0A%20%20%20%20f%20%3D%20%5B%5D%0A%20%20%20%20if%20status_select.value%3A%0A%20%20%20%20%20%20%20%20vals%20%3D%20%22%2C%22.join(%5B%22'%22%20%2B%20v.replace(%22'%22%2C%20%22''%22)%20%2B%20%22'%22%20for%20v%20in%20status_select.value%5D)%0A%20%20%20%20%20%20%20%20f.append(f%22orders.status%20IN%20(%7Bvals%7D)%22)%0A%20%20%20%20if%20region_select.value%3A%0A%20%20%20%20%20%20%20%20vals%20%3D%20%22%2C%22.join(%5B%22'%22%20%2B%20v.replace(%22'%22%2C%20%22''%22)%20%2B%20%22'%22%20for%20v%20in%20region_select.value%5D)%0A%20%20%20%20%20%20%20%20f.append(f%22orders.region%20IN%20(%7Bvals%7D)%22)%0A%20%20%20%20if%20category_select.value%3A%0A%20%20%20%20%20%20%20%20vals%20%3D%20%22%2C%22.join(%5B%22'%22%20%2B%20v.replace(%22'%22%2C%20%22''%22)%20%2B%20%22'%22%20for%20v%20in%20category_select.value%5D)%0A%20%20%20%20%20%20%20%20f.append(f%22orders.category%20IN%20(%7Bvals%7D)%22)%0A%20%20%20%20if%20tier_select.value%3A%0A%20%20%20%20%20%20%20%20vals%20%3D%20%22%2C%22.join(%5B%22'%22%20%2B%20v.replace(%22'%22%2C%20%22''%22)%20%2B%20%22'%22%20for%20v%20in%20tier_select.value%5D)%0A%20%20%20%20%20%20%20%20f.append(f%22customers.tier%20IN%20(%7Bvals%7D)%22)%0A%20%20%20%20return%20f%0A%0A%23%20Token%20that%20captures%20UI%20state%20so%20downstream%20cells%20re-execute%20when%20filters%20change%0AFILTERS_STATE%20%3D%20(%0A%20%20%20%20tuple(status_select.value)%2C%0A%20%20%20%20tuple(region_select.value)%2C%0A%20%20%20%20tuple(category_select.value)%2C%0A%20%20%20%20tuple(tier_select.value)%2C%0A%20%20%20%20month_select.value%2C%0A)%0A%0Adef%20run_query(metrics%2C%20dims%2C%20order_by%3DNone%2C%20limit%3DNone%2C%20extra_filters%3DNone%2C%20_state%3A%20object%20%7C%20None%20%3D%20None)%3A%0A%20%20%20%20%23%20_state%20is%20unused%20inside%3B%20it%20exists%20to%20make%20marimo%20track%20dependencies%20on%20UI%0A%20%20%20%20filters%20%3D%20build_filters()%0A%20%20%20%20if%20extra_filters%3A%0A%20%20%20%20%20%20%20%20filters%20%3D%20filters%20%2B%20list(extra_filters)%0A%20%20%20%20dims_sql%20%3D%20list(dims)%0A%20%20%20%20injected%20%3D%20False%0A%20%20%20%20%23%20Force-join%20customers%20when%20tier%20filter%20is%20active%20to%20satisfy%20generator's%20model%20discovery%0A%20%20%20%20if%20tier_select.value%20and%20not%20any(d.startswith(%22customers.%22)%20for%20d%20in%20dims_sql)%3A%0A%20%20%20%20%20%20%20%20dims_sql.append(%22customers.tier%22)%0A%20%20%20%20%20%20%20%20injected%20%3D%20True%0A%0A%20%20%20%20sql%20%3D%20generator.generate(metrics%3Dmetrics%2C%20dimensions%3Ddims_sql%2C%20filters%3Dfilters%2C%20order_by%3Dorder_by%2C%20limit%3Dlimit)%0A%20%20%20%20cur%20%3D%20conn.execute(sql)%0A%20%20%20%20rows%20%3D%20cur.fetchall()%0A%20%20%20%20cols%20%3D%20%5Bd%5B0%5D%20for%20d%20in%20cur.description%5D%0A%20%20%20%20data%20%3D%20%5Bdict(zip(cols%2C%20r))%20for%20r%20in%20rows%5D%0A%20%20%20%20%23%20Drop%20injected%20column%20if%20the%20caller%20didn't%20request%20it%20explicitly%0A%20%20%20%20if%20injected%20and%20data%20and%20%22tier%22%20in%20data%5B0%5D%20and%20not%20any(d.endswith(%22tier%22)%20or%20d.endswith(%22.tier%22)%20for%20d%20in%20dims)%3A%0A%20%20%20%20%20%20%20%20for%20rec%20in%20data%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20rec.pop(%22tier%22%2C%20None)%0A%20%20%20%20return%20data%2C%20sql%0ARUN_QUERY_READY%20%3D%20True\n\n\n    \n    \n    \n    %23%20KPIs%20via%20Sidemantic%20%E2%86%92%20DuckDB%20(two-column%20layout)%0Aimport%20datetime%20as%20_dt%0A%0Akpi_rows%2C%20_%20%3D%20run_query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%2C%20%22orders.order_count%22%2C%20%22orders.avg_order_value%22%5D%2C%0A%20%20%20%20dims%3D%5B%5D%2C%20_state%3DFILTERS_STATE%2C%0A)%0A%0Arevenue%20%3D%20float(kpi_rows%5B0%5D.get(%22revenue%22%2C%200.0))%20if%20kpi_rows%20else%200.0%0Aorders%20%20%3D%20int(kpi_rows%5B0%5D.get(%22order_count%22%2C%200))%20if%20kpi_rows%20else%200%0Aaov%20%20%20%20%20%3D%20float(kpi_rows%5B0%5D.get(%22avg_order_value%22%2C%200.0))%20if%20kpi_rows%20else%200.0%0A%0Asel_month%20%3D%20month_select.value%20%20%23%20'YYYY-MM'%0A_y%2C%20_m%20%3D%20map(int%2C%20sel_month.split('-'))%0A_month_start%20%3D%20_dt.date(_y%2C%20_m%2C%201).isoformat()%0A_q_start_month%20%3D%20((_m%20-%201)%2F%2F3)*3%20%2B%201%0A_q_start%20%3D%20_dt.date(_y%2C%20_q_start_month%2C%201).isoformat()%0A_y_start%20%3D%20_dt.date(_y%2C%201%2C%201).isoformat()%0A%0A%23%20Compute%20period-to-date%20by%20filtering%20period%20via%20SQL%2C%20still%20using%20the%20same%20metric%0Amtd_rows%2C%20_%20%3D%20run_query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%5D%2C%0A%20%20%20%20extra_filters%3D%5Bf%22DATE_TRUNC('month'%2C%20orders.order_date)%20%3D%20DATE%20'%7B_month_start%7D'%22%5D%2C%20_state%3DFILTERS_STATE%0A)%0Amtd%20%3D%20float(mtd_rows%5B0%5D.get(%22revenue%22%2C%200.0))%20if%20mtd_rows%20else%200.0%0A%0Aqtd_rows%2C%20_%20%3D%20run_query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%5D%2C%0A%20%20%20%20extra_filters%3D%5Bf%22DATE_TRUNC('quarter'%2C%20orders.order_date)%20%3D%20DATE%20'%7B_q_start%7D'%22%5D%2C%20_state%3DFILTERS_STATE%0A)%0Aqtd%20%3D%20float(qtd_rows%5B0%5D.get(%22revenue%22%2C%200.0))%20if%20qtd_rows%20else%200.0%0A%0Aytd_rows%2C%20_%20%3D%20run_query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%5D%2C%0A%20%20%20%20extra_filters%3D%5Bf%22DATE_TRUNC('year'%2C%20orders.order_date)%20%3D%20DATE%20'%7B_y_start%7D'%22%5D%2C%20_state%3DFILTERS_STATE%0A)%0Aytd%20%3D%20float(ytd_rows%5B0%5D.get(%22revenue%22%2C%200.0))%20if%20ytd_rows%20else%200.0%0A%0Aleft_metrics%20%3D%20mo.md(f%22%22%22%0A**Revenue%3A**%20%24%7Brevenue%3A%2C.2f%7D%0A**Orders%3A**%20%7Borders%7D%0A**AOV%3A**%20%24%7Baov%3A%2C.2f%7D%0A%22%22%22)%0A%0Aptd_metrics%20%3D%20mo.md(f%22%22%22%0A**MTD%20Revenue%3A**%20%24%7Bmtd%3A%2C.2f%7D%0A**QTD%20Revenue%3A**%20%24%7Bqtd%3A%2C.2f%7D%0A**YTD%20Revenue%3A**%20%24%7Bytd%3A%2C.2f%7D%0A%22%22%22)%0A%0Aleft_col%20%3D%20mo.vstack(%5Bmo.md('%23%23%23%20Key%20Metrics')%2C%20left_metrics%5D)%0Aright_col%20%3D%20mo.vstack(%5Bmo.md(f'%23%23%23%20Period-to-date%20(%7Bsel_month%7D)')%2C%20ptd_metrics%5D)%0A%0Amo.vstack(%5B%0A%20%20%20%20mo.hstack(%5Bleft_col%2C%20right_col%5D)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A8px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)\n\n\n    \n    \n    \n    %23%20Revenue%20by%20month%0Adata%2C%20sql_month%20%3D%20run_query(metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%22orders.order_date__month%22%2C%20%22orders.status%22%5D%2C%20order_by%3D%5B%22orders.order_date__month%22%5D%2C%20_state%3DFILTERS_STATE)%0Achart_month%20%3D%20(%0A%20%20%20%20alt.Chart(alt.Data(values%3Ddata))%0A%20%20%20%20.mark_bar()%0A%20%20%20%20.encode(%0A%20%20%20%20%20%20%20%20x%3Dalt.X(%22order_date__month%3AT%22%2C%20title%3D%22Month%22)%2C%0A%20%20%20%20%20%20%20%20y%3Dalt.Y(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%2C%0A%20%20%20%20%20%20%20%20color%3Dalt.Color(%22status%3AN%22)%2C%0A%20%20%20%20%20%20%20%20tooltip%3D%5B%22order_date__month%3AT%22%2C%20%22status%3AN%22%2C%20alt.Tooltip(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%5D%2C%0A%20%20%20%20)%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Revenue%20by%20Month')%2C%0A%20%20%20%20mo.ui.altair_chart(chart_month)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)%0A%0A%23%20Revenue%20by%20category%20(top%2010)%0Atop_cat_df%2C%20_%20%3D%20run_query(metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%22orders.category%22%5D%2C%20order_by%3D%5B%22revenue%20DESC%22%5D%2C%20limit%3D10%2C%20_state%3DFILTERS_STATE)%0Achart_cat%20%3D%20(%0A%20%20%20%20alt.Chart(alt.Data(values%3Dtop_cat_df))%0A%20%20%20%20.mark_bar()%0A%20%20%20%20.encode(%0A%20%20%20%20%20%20%20%20x%3Dalt.X(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%2C%0A%20%20%20%20%20%20%20%20y%3Dalt.Y(%22category%3AN%22%2C%20sort%3D'-x'%2C%20title%3D%22Category%22)%2C%0A%20%20%20%20%20%20%20%20tooltip%3D%5B%22category%3AN%22%2C%20alt.Tooltip(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%5D%2C%0A%20%20%20%20)%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Top%20Categories%20by%20Revenue')%2C%0A%20%20%20%20mo.ui.altair_chart(chart_cat)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)%0A%0A%23%20Avg%20order%20value%20by%20region%20over%20time%0Achart_aov_region%20%3D%20(%0A%20%20%20%20alt.Chart(alt.Data(values%3Drun_query(metrics%3D%5B%22orders.avg_order_value%22%5D%2C%20dims%3D%5B%22orders.region%22%2C%20%22orders.order_date__month%22%5D%2C%20order_by%3D%5B%22orders.order_date__month%22%5D%2C%20_state%3DFILTERS_STATE)%5B0%5D))%0A%20%20%20%20.mark_line()%0A%20%20%20%20.encode(%0A%20%20%20%20%20%20%20%20x%3Dalt.X(%22order_date__month%3AT%22%2C%20title%3D%22Month%22)%2C%0A%20%20%20%20%20%20%20%20y%3Dalt.Y(%22avg_order_value%3AQ%22%2C%20title%3D%22Avg%20Order%20Value%22)%2C%0A%20%20%20%20%20%20%20%20color%3Dalt.Color(%22region%3AN%22)%2C%0A%20%20%20%20%20%20%20%20tooltip%3D%5B%22order_date__month%3AT%22%2C%20%22region%3AN%22%2C%20alt.Tooltip(%22avg_order_value%3AQ%22%2C%20title%3D%22AOV%22)%5D%2C%0A%20%20%20%20)%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Avg%20Order%20Value%20by%20Region%20Over%20Time')%2C%0A%20%20%20%20mo.ui.altair_chart(chart_aov_region)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)%0A%0A%23%20Revenue%20by%20region%0Achart_region%20%3D%20(%0A%20%20%20%20alt.Chart(alt.Data(values%3Drun_query(metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%22orders.region%22%5D%2C%20order_by%3D%5B%22revenue%20DESC%22%5D%2C%20_state%3DFILTERS_STATE)%5B0%5D))%0A%20%20%20%20.mark_bar()%0A%20%20%20%20.encode(%0A%20%20%20%20%20%20%20%20x%3Dalt.X(%22region%3AN%22%2C%20sort%3D'-y'%2C%20title%3D%22Region%22)%2C%0A%20%20%20%20%20%20%20%20y%3Dalt.Y(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%2C%0A%20%20%20%20%20%20%20%20color%3Dalt.Color(%22region%3AN%22)%2C%0A%20%20%20%20%20%20%20%20tooltip%3D%5B%22region%3AN%22%2C%20alt.Tooltip(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%5D%2C%0A%20%20%20%20)%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Revenue%20by%20Region')%2C%0A%20%20%20%20mo.ui.altair_chart(chart_region)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)%0A%0A%23%20Revenue%20heatmap%20(month%20x%20category)%0Achart_heat%20%3D%20(%0A%20%20%20%20alt.Chart(alt.Data(values%3Drun_query(metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%22orders.order_date__month%22%2C%20%22orders.category%22%5D%2C%20order_by%3D%5B%22orders.order_date__month%22%5D%2C%20_state%3DFILTERS_STATE)%5B0%5D))%0A%20%20%20%20.mark_rect()%0A%20%20%20%20.encode(%0A%20%20%20%20%20%20%20%20x%3Dalt.X(%22order_date__month%3AT%22%2C%20title%3D%22Month%22)%2C%0A%20%20%20%20%20%20%20%20y%3Dalt.Y(%22category%3AN%22%2C%20title%3D%22Category%22)%2C%0A%20%20%20%20%20%20%20%20color%3Dalt.Color(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%2C%0A%20%20%20%20)%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Revenue%20Heatmap%20(Month%20%C3%97%20Category)')%2C%0A%20%20%20%20mo.ui.altair_chart(chart_heat)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)\n\n\n    \n    \n    \n    %23%20Multi-hop%20join%20demo%20via%20Sidemantic%0Ajoin_df%2C%20_%20%3D%20run_query(metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%22region_map.region_group%22%2C%20%22customers.tier%22%5D%2C%20order_by%3D%5B%22revenue%20DESC%22%5D%2C%20_state%3DFILTERS_STATE)%0Achart_join%20%3D%20(%0A%20%20%20%20alt.Chart(alt.Data(values%3Djoin_df))%0A%20%20%20%20.mark_bar()%0A%20%20%20%20.encode(%0A%20%20%20%20%20%20%20%20x%3Dalt.X(%22region_group%3AN%22%2C%20title%3D%22Region%20Group%22)%2C%0A%20%20%20%20%20%20%20%20y%3Dalt.Y(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%2C%0A%20%20%20%20%20%20%20%20color%3Dalt.Color(%22tier%3AN%22)%2C%0A%20%20%20%20%20%20%20%20tooltip%3D%5B%22region_group%3AN%22%2C%20%22tier%3AN%22%2C%20alt.Tooltip(%22revenue%3AQ%22%2C%20title%3D%22Revenue%22)%5D%2C%0A%20%20%20%20)%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Revenue%20by%20Region%20Group%20%C3%97%20Tier')%2C%0A%20%20%20%20mo.ui.altair_chart(chart_join)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)%0A%0A%23%20Top%20customers%20(via%20Sidemantic)%0Atop_cust_df%2C%20_%20%3D%20run_query(metrics%3D%5B%22orders.revenue%22%5D%2C%20dims%3D%5B%22orders.customer_id%22%5D%2C%20order_by%3D%5B%22revenue%20DESC%22%5D%2C%20limit%3D20%2C%20_state%3DFILTERS_STATE)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Top%20Customers%20by%20Revenue')%2C%0A%20%20%20%20mo.ui.table(top_cust_df)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)%0A\n\n\n    \n    \n    \n    %23%20Detailed%20rows%20(filtered)%20%E2%80%94%20aggregated%20by%20date%2Fstatus%2Fregion%2Fcategory%0Adetail_df%2C%20_%20%3D%20run_query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%2C%20%22orders.order_count%22%5D%2C%0A%20%20%20%20dims%3D%5B%22orders.order_date__day%22%2C%20%22orders.status%22%2C%20%22orders.region%22%2C%20%22orders.category%22%5D%2C%0A%20%20%20%20order_by%3D%5B%22orders.order_date__day%22%5D%2C%20_state%3DFILTERS_STATE%2C%0A)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Detailed%20Rows')%2C%0A%20%20%20%20mo.ui.table(detail_df)%2C%0A%20%20%20%20mo.md('%3Cdiv%20style%3D%22height%3A16px%22%3E%3C%2Fdiv%3E')%2C%0A%5D)\n\n\n    \n    \n    \n    %23%20Interactive%20Query%20(SQL)%0A%23%20Build%20query%20from%20semantic%20selections%2C%20edit%20SQL%2C%20and%20run%0A%0Amo.md(%22%23%23%23%20Interactive%20Query%22)%0A%0A%23%20Build%20metric%20and%20dimension%20options%20from%20the%20semantic%20graph%0A_metric_opts%20%3D%20%5B%5D%0Afor%20_mname%2C%20_model%20in%20graph.models.items()%3A%0A%20%20%20%20for%20_me%20in%20_model.metrics%3A%0A%20%20%20%20%20%20%20%20_metric_opts.append(f%22%7B_mname%7D.%7B_me.name%7D%22)%0A_metric_opts%20%3D%20sorted(set(_metric_opts))%0A%0A_dim_opts%20%3D%20%5B%5D%0Afor%20_mname%2C%20_model%20in%20graph.models.items()%3A%0A%20%20%20%20for%20_d%20in%20_model.dimensions%3A%0A%20%20%20%20%20%20%20%20if%20getattr(_d%2C%20%22type%22%2C%20%22%22)%20%3D%3D%20%22time%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20_g%20in%20(%22day%22%2C%20%22month%22%2C%20%22quarter%22%2C%20%22year%22)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_dim_opts.append(f%22%7B_mname%7D.%7B_d.name%7D__%7B_g%7D%22)%0A%20%20%20%20%20%20%20%20_dim_opts.append(f%22%7B_mname%7D.%7B_d.name%7D%22)%0A_dim_opts%20%3D%20sorted(set(_dim_opts))%0A%0Aiq_metrics%20%3D%20mo.ui.multiselect(options%3D_metric_opts%2C%20value%3D%5B%22orders.revenue%22%5D%2C%20label%3D%22Metrics%22)%0Aiq_dims%20%3D%20mo.ui.multiselect(options%3D_dim_opts%2C%20value%3D%5B%22orders.order_date__month%22%5D%2C%20label%3D%22Dimensions%22)%0Aiq_limit%20%3D%20mo.ui.number(value%3D50%2C%20label%3D%22Limit%22)%0Aiq_compile%20%3D%20mo.ui.button(label%3D%22Compile%20SQL%22)%0Aiq_run%20%3D%20mo.ui.button(label%3D%22Run%20SQL%22)%0Aiq_sql%20%3D%20mo.ui.code_editor(value%3D%22--%20Click%20Compile%20SQL%20to%20generate%20from%20selections%22%2C%20language%3D%22sql%22%2C%20min_height%3D180)%0Aiq_results%20%3D%20mo.ui.table(%5B%5D)%0A%0Amo.vstack(%5B%0A%20%20%20%20mo.hstack(%5Biq_metrics%2C%20iq_dims%2C%20iq_limit%5D)%2C%0A%20%20%20%20mo.hstack(%5Biq_compile%2C%20iq_run%5D)%2C%0A%20%20%20%20iq_sql%2C%0A%20%20%20%20iq_results%2C%0A%5D)\n\n\n    \n    \n    \n    %23%20Interactive%20Query%20actions%20(separate%20from%20UI%20creation)%0Aif%20iq_compile.value%3A%0A%20%20%20%20try%3A%0A%20%20%20%20%20%20%20%20sel_metrics%20%3D%20list(iq_metrics.value)%20or%20%5B%22orders.revenue%22%5D%0A%20%20%20%20%20%20%20%20sel_dims%20%3D%20list(iq_dims.value)%20or%20%5B%5D%0A%20%20%20%20%20%20%20%20row_limit%20%3D%20int(iq_limit.value%20or%2050)%0A%20%20%20%20%20%20%20%20sql_text%20%3D%20generator.generate(metrics%3Dsel_metrics%2C%20dimensions%3Dsel_dims%2C%20filters%3Dbuild_filters()%2C%20order_by%3Dsel_dims%20or%20None%2C%20limit%3Drow_limit)%0A%20%20%20%20%20%20%20%20iq_sql.value%20%3D%20sql_text%0A%20%20%20%20except%20Exception%20as%20e%3A%0A%20%20%20%20%20%20%20%20iq_sql.value%20%3D%20f%22--%20Error%20compiling%20SQL%3A%20%7Be%7D%22%0A%0Aif%20iq_run.value%3A%0A%20%20%20%20try%3A%0A%20%20%20%20%20%20%20%20to_run%20%3D%20(iq_sql.value%20or%20%22%22).strip()%0A%20%20%20%20%20%20%20%20if%20to_run%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20cur%20%3D%20conn.execute(to_run)%0A%20%20%20%20%20%20%20%20%20%20%20%20cols%20%3D%20%5Bd%5B0%5D%20for%20d%20in%20cur.description%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20rows%20%3D%20%5Bdict(zip(cols%2C%20r))%20for%20r%20in%20cur.fetchall()%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20iq_results.value%20%3D%20rows%0A%20%20%20%20except%20Exception%20as%20e%3A%0A%20%20%20%20%20%20%20%20iq_results.value%20%3D%20%5B%7B%22error%22%3A%20str(e)%7D%5D\n\n\n    \n    \n    \n    %23%20Data%20Model%0Apython_src%20%3D%20%22%22%22%0Afrom%20sidemantic.core.model%20import%20Model%0Afrom%20sidemantic.core.dimension%20import%20Dimension%0Afrom%20sidemantic.core.metric%20import%20Metric%0Afrom%20sidemantic.core.relationship%20import%20Relationship%0Afrom%20sidemantic.core.segment%20import%20Segment%0Afrom%20sidemantic.core.semantic_graph%20import%20SemanticGraph%0Afrom%20sidemantic.sql.generator_v2%20import%20SQLGenerator%0A%0Agraph%20%3D%20SemanticGraph()%0A%0Aorders_model%20%3D%20Model(%0A%20%20%20%20name%3D%22orders%22%2C%0A%20%20%20%20table%3D%22orders%22%2C%0A%20%20%20%20primary_key%3D%22id%22%2C%0A%20%20%20%20dimensions%3D%5B%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22status%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22status%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22order_date%22%2C%20type%3D%22time%22%2C%20expr%3D%22order_date%22%2C%20granularity%3D%22day%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22region%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22region%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22category%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22category%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20metrics%3D%5B%0A%20%20%20%20%20%20%20%20Metric(name%3D%22revenue%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22amount%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22order_count%22%2C%20agg%3D%22count%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22avg_order_value%22%2C%20agg%3D%22avg%22%2C%20expr%3D%22amount%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22cost%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22cost%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22profit%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22profit%22)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22returns%22%2C%20agg%3D%22count%22%2C%20filters%3D%5B%22%7Bmodel%7D.status%20%3D%20'returned'%22%5D)%2C%0A%20%20%20%20%20%20%20%20Metric(name%3D%22return_rate%22%2C%20type%3D%22ratio%22%2C%20numerator%3D%22orders.returns%22%2C%20denominator%3D%22orders.order_count%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20segments%3D%5B%0A%20%20%20%20%20%20%20%20Segment(name%3D%22completed%22%2C%20sql%3D%22%7Bmodel%7D.status%20%3D%20'completed'%22)%2C%0A%20%20%20%20%20%20%20%20Segment(name%3D%22high_value%22%2C%20sql%3D%22%7Bmodel%7D.amount%20%3E%3D%20300%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20relationships%3D%5BRelationship(name%3D%22customers%22%2C%20type%3D%22many_to_one%22%2C%20foreign_key%3D%22customer_id%22)%5D%2C%0A)%0A%0Acustomers_model%20%3D%20Model(%0A%20%20%20%20name%3D%22customers%22%2C%0A%20%20%20%20table%3D%22customers%22%2C%0A%20%20%20%20primary_key%3D%22id%22%2C%0A%20%20%20%20dimensions%3D%5B%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22tier%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22tier%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22region%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22region%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20relationships%3D%5BRelationship(name%3D%22region_map%22%2C%20type%3D%22many_to_one%22%2C%20foreign_key%3D%22region%22%2C%20primary_key%3D%22region%22)%5D%2C%0A)%0A%0Aregion_map_model%20%3D%20Model(%0A%20%20%20%20name%3D%22region_map%22%2C%0A%20%20%20%20table%3D%22region_map%22%2C%0A%20%20%20%20primary_key%3D%22region%22%2C%0A%20%20%20%20dimensions%3D%5BDimension(name%3D%22region_group%22%2C%20type%3D%22categorical%22%2C%20expr%3D%22region_group%22)%5D%2C%0A)%0A%0Agraph.add_model(orders_model)%0Agraph.add_model(customers_model)%0Agraph.add_model(region_map_model)%0A%0Agenerator%20%3D%20SQLGenerator(graph%2C%20dialect%3D%22duckdb%22)%0A%22%22%22\n\n\n    \n    \n    \n    yaml_src%20%3D%20%22%22%22%0Amodels%3A%0A%20%20-%20name%3A%20orders%0A%20%20%20%20table%3A%20orders%0A%20%20%20%20primary_key%3A%20id%0A%20%20%20%20dimensions%3A%0A%20%20%20%20%20%20-%20name%3A%20status%0A%20%20%20%20%20%20%20%20type%3A%20categorical%0A%20%20%20%20%20%20%20%20expr%3A%20status%0A%20%20%20%20%20%20-%20name%3A%20order_date%0A%20%20%20%20%20%20%20%20type%3A%20time%0A%20%20%20%20%20%20%20%20expr%3A%20order_date%0A%20%20%20%20%20%20%20%20granularity%3A%20day%0A%20%20%20%20%20%20-%20name%3A%20region%0A%20%20%20%20%20%20%20%20type%3A%20categorical%0A%20%20%20%20%20%20%20%20expr%3A%20region%0A%20%20%20%20%20%20-%20name%3A%20category%0A%20%20%20%20%20%20%20%20type%3A%20categorical%0A%20%20%20%20%20%20%20%20expr%3A%20category%0A%20%20%20%20metrics%3A%0A%20%20%20%20%20%20-%20name%3A%20revenue%0A%20%20%20%20%20%20%20%20agg%3A%20sum%0A%20%20%20%20%20%20%20%20expr%3A%20amount%0A%20%20%20%20%20%20-%20name%3A%20order_count%0A%20%20%20%20%20%20%20%20agg%3A%20count%0A%20%20%20%20%20%20-%20name%3A%20avg_order_value%0A%20%20%20%20%20%20%20%20agg%3A%20avg%0A%20%20%20%20%20%20%20%20expr%3A%20amount%0A%20%20%20%20%20%20-%20name%3A%20cost%0A%20%20%20%20%20%20%20%20agg%3A%20sum%0A%20%20%20%20%20%20%20%20expr%3A%20cost%0A%20%20%20%20%20%20-%20name%3A%20profit%0A%20%20%20%20%20%20%20%20agg%3A%20sum%0A%20%20%20%20%20%20%20%20expr%3A%20profit%0A%20%20%20%20%20%20-%20name%3A%20returns%0A%20%20%20%20%20%20%20%20agg%3A%20count%0A%20%20%20%20%20%20%20%20filters%3A%0A%20%20%20%20%20%20%20%20%20%20-%20%22%7Bmodel%7D.status%20%3D%20'returned'%22%0A%20%20%20%20%20%20-%20name%3A%20return_rate%0A%20%20%20%20%20%20%20%20type%3A%20ratio%0A%20%20%20%20%20%20%20%20numerator%3A%20orders.returns%0A%20%20%20%20%20%20%20%20denominator%3A%20orders.order_count%0A%20%20%20%20segments%3A%0A%20%20%20%20%20%20-%20name%3A%20completed%0A%20%20%20%20%20%20%20%20sql%3A%20%22%7Bmodel%7D.status%20%3D%20'completed'%22%0A%20%20%20%20%20%20-%20name%3A%20high_value%0A%20%20%20%20%20%20%20%20sql%3A%20%22%7Bmodel%7D.amount%20%3E%3D%20300%22%0A%20%20%20%20relationships%3A%0A%20%20%20%20%20%20-%20name%3A%20customers%0A%20%20%20%20%20%20%20%20type%3A%20many_to_one%0A%20%20%20%20%20%20%20%20foreign_key%3A%20customer_id%0A%20%20-%20name%3A%20customers%0A%20%20%20%20table%3A%20customers%0A%20%20%20%20primary_key%3A%20id%0A%20%20%20%20dimensions%3A%0A%20%20%20%20%20%20-%20name%3A%20tier%0A%20%20%20%20%20%20%20%20type%3A%20categorical%0A%20%20%20%20%20%20%20%20expr%3A%20tier%0A%20%20%20%20%20%20-%20name%3A%20region%0A%20%20%20%20%20%20%20%20type%3A%20categorical%0A%20%20%20%20%20%20%20%20expr%3A%20region%0A%20%20%20%20relationships%3A%0A%20%20%20%20%20%20-%20name%3A%20region_map%0A%20%20%20%20%20%20%20%20type%3A%20many_to_one%0A%20%20%20%20%20%20%20%20foreign_key%3A%20region%0A%20%20%20%20%20%20%20%20primary_key%3A%20region%0A%20%20-%20name%3A%20region_map%0A%20%20%20%20table%3A%20region_map%0A%20%20%20%20primary_key%3A%20region%0A%20%20%20%20dimensions%3A%0A%20%20%20%20%20%20-%20name%3A%20region_group%0A%20%20%20%20%20%20%20%20type%3A%20categorical%0A%20%20%20%20%20%20%20%20expr%3A%20region_group%0A%22%22%22\n\n\n    \n    Data ModelPython DefinitionYAML Definition\n    \n    %23%20Data%20Model%20(code%20%2B%20ER%20diagram)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%20Data%20Model')%2C%0A%20%20%20%20mo.md('%23%23%23%20Python%20Definition')%2C%0A%20%20%20%20mo.ui.code_editor(value%3Dpython_src%2C%20language%3D'python'%2C%20disabled%3DTrue%2C%20min_height%3D360)%2C%0A%20%20%20%20mo.md('%23%23%23%20YAML%20Definition')%2C%0A%20%20%20%20mo.ui.code_editor(value%3Dyaml_src%2C%20language%3D'yaml'%2C%20disabled%3DTrue%2C%20min_height%3D420)%2C%0A%5D)\n\n\n    \n    Data Model (ER Diagram)\n    \n    %23%20Mermaid%20ER%20diagram%20from%20Sidemantic%20graph%0Adef%20_build_er_mermaid(g)%3A%0A%20%20%20%20lines%20%3D%20%5B%22erDiagram%22%5D%0A%0A%20%20%20%20%23%20Entities%20with%20a%20handful%20of%20fields%0A%20%20%20%20for%20m_name%2C%20m%20in%20g.models.items()%3A%0A%20%20%20%20%20%20%20%20%23%20Base%20entity%20with%20primary%20key%20%2B%20dimensions%20only%0A%20%20%20%20%20%20%20%20base_attrs%20%3D%20%5B%5D%0A%20%20%20%20%20%20%20%20pk%20%3D%20m.primary_key%20or%20%22id%22%0A%20%20%20%20%20%20%20%20base_attrs.append(f%22%20%20string%20%7Bpk%7D%20PK%22)%0A%20%20%20%20%20%20%20%20for%20d%20in%20m.dimensions%5B%3A6%5D%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20getattr(d%2C%20%22type%22%2C%20%22%22)%20%3D%3D%20%22time%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20dtype%20%3D%20%22date%22%0A%20%20%20%20%20%20%20%20%20%20%20%20elif%20getattr(d%2C%20%22type%22%2C%20%22%22)%20in%20(%22number%22%2C%20%22numeric%22)%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20dtype%20%3D%20%22number%22%0A%20%20%20%20%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20dtype%20%3D%20%22string%22%0A%20%20%20%20%20%20%20%20%20%20%20%20base_attrs.append(f%22%20%20%7Bdtype%7D%20%7Bd.name%7D%22)%0A%20%20%20%20%20%20%20%20lines.append(f%22%7Bm_name%7D%20%7B%7B%22)%0A%20%20%20%20%20%20%20%20lines.extend(base_attrs)%0A%20%20%20%20%20%20%20%20lines.append(%22%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Separate%20%3Cmodel%3E_metrics%20entity%20listing%20all%20metrics%0A%20%20%20%20%20%20%20%20metrics_list%20%3D%20m.metrics%5B%3A8%5D%0A%20%20%20%20%20%20%20%20if%20metrics_list%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20metric_attrs%20%3D%20%5Bf%22%20%20metric%20%7Bme.name%7D%22%20for%20me%20in%20metrics_list%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20metrics_entity%20%3D%20f%22%7Bm_name%7D_metrics%22%0A%20%20%20%20%20%20%20%20%20%20%20%20lines.append(f%22%7Bmetrics_entity%7D%20%7B%7B%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20lines.extend(metric_attrs)%0A%20%20%20%20%20%20%20%20%20%20%20%20lines.append(%22%7D%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20One-to-one%20conceptual%20link%20from%20model%20to%20its%20metrics%20definition%0A%20%20%20%20%20%20%20%20%20%20%20%20lines.append(f%22%7Bm_name%7D%20%7C%7C--%7C%7C%20%7Bmetrics_entity%7D%20%3A%20metrics%22)%0A%0A%20%20%20%20%23%20Relationships%0A%20%20%20%20for%20m_name%2C%20m%20in%20g.models.items()%3A%0A%20%20%20%20%20%20%20%20for%20rel%20in%20m.relationships%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20src%20%3D%20m_name%0A%20%20%20%20%20%20%20%20%20%20%20%20dst%20%3D%20rel.name%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20rel.type%20%3D%3D%20%22many_to_one%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20card%20%3D%20%22%7Do--%7C%7C%22%20%20%23%20many-to-one%20(child%20to%20parent)%0A%20%20%20%20%20%20%20%20%20%20%20%20elif%20rel.type%20%3D%3D%20%22one_to_many%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20card%20%3D%20%22%7C%7C--o%7B%22%20%20%23%20one-to-many%20(parent%20to%20child)%0A%20%20%20%20%20%20%20%20%20%20%20%20elif%20rel.type%20%3D%3D%20%22one_to_one%22%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20card%20%3D%20%22%7C%7C--%7C%7C%22%20%20%23%20one-to-one%0A%20%20%20%20%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20card%20%3D%20%22%7C%7C--%7C%7C%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Build%20a%20compact%2C%20single-token%20label%20to%20avoid%20Mermaid%20parsing%20issues%0A%20%20%20%20%20%20%20%20%20%20%20%20l_fk%20%3D%20rel.sql_expr.replace(%22.%22%2C%20%22_%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20r_pk%20%3D%20(rel.related_key%20or%20%22id%22).replace(%22.%22%2C%20%22_%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20label%20%3D%20f%22%7Bsrc%7D_%7Bl_fk%7D_to_%7Bdst%7D_%7Br_pk%7D%22%0A%20%20%20%20%20%20%20%20%20%20%20%20lines.append(f%22%7Bsrc%7D%20%7Bcard%7D%20%7Bdst%7D%20%3A%20%7Blabel%7D%22)%0A%0A%20%20%20%20return%20%22%5Cn%22.join(lines)%0A%0Aer_diagram%20%3D%20_build_er_mermaid(graph)%0Amo.vstack(%5B%0A%20%20%20%20mo.md('%23%23%23%20Data%20Model%20(ER%20Diagram)')%2C%0A%20%20%20%20mo.mermaid(er_diagram)%2C%0A%5D)"
  },
  {
    "objectID": "YAML_FORMAT.html",
    "href": "YAML_FORMAT.html",
    "title": "YAML Format Reference",
    "section": "",
    "text": "Complete specification for Sidemantic YAML files.\n\n\n# yaml-language-server: $schema=./sidemantic-schema.json\n\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    dimensions: [...]\n    metrics: [...]\n    relationships: [...]\n\nmetrics:\n  - name: total_revenue\n    sql: orders.revenue\n\nparameters:\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\"\n\n\n\nmodels:\n  - name: string              # Required - unique identifier\n    table: string             # Physical table (or use sql)\n    sql: string               # SQL query (or use table)\n    primary_key: string       # Required - primary key column\n    description: string       # Optional\n\n    dimensions: [...]         # Optional\n    metrics: [...]            # Optional (model-level aggregations)\n    relationships: [...]      # Optional\n\n\n\ndimensions:\n  - name: string              # Required\n    type: categorical|time|boolean|numeric  # Required\n    sql: string               # SQL expression (defaults to name)\n    description: string       # Optional\n    label: string             # Optional\n\n    # For time dimensions only\n    granularity: hour|day|week|month|quarter|year\n\n\n\ncategorical: Text/enum values (status, region, product_name)\ntime: Dates/timestamps (order_date, created_at)\nboolean: True/false (is_active, is_deleted)\nnumeric: Numbers (price_tier, quantity_bucket)\n\n\n\n\ndimensions:\n  # Categorical\n  - name: status\n    type: categorical\n    sql: status\n\n  # Time with granularity\n  - name: order_date\n    type: time\n    sql: created_at\n    granularity: day\n\n  # Boolean\n  - name: is_active\n    type: boolean\n    sql: active\n\n  # SQL expression\n  - name: customer_tier\n    type: categorical\n    sql: |\n      CASE\n        WHEN amount &gt; 1000 THEN 'premium'\n        WHEN amount &gt; 100 THEN 'standard'\n        ELSE 'basic'\n      END\n\n\n\n\nModel-level metrics are aggregations defined on a single model. These become the building blocks for graph-level metrics.\n\n\nmetrics:\n  - name: string              # Required\n    agg: sum|count|count_distinct|avg|min|max|median  # Required\n    sql: string               # SQL expression (defaults to * for count)\n    filters: [string]         # Optional WHERE conditions\n    description: string       # Optional\n    fill_nulls_with: value    # Optional default for NULL\n\n\n\nmetrics:\n  # Simple sum\n  - name: revenue\n    agg: sum\n    sql: amount\n\n  # Count\n  - name: order_count\n    agg: count\n\n  # Average\n  - name: avg_order_value\n    agg: avg\n    sql: amount\n\n  # With filter\n  - name: completed_revenue\n    agg: sum\n    sql: amount\n    filters: [\"status = 'completed'\"]\n\n  # SQL expression\n  - name: total_value\n    agg: sum\n    sql: \"quantity * price * (1 - discount)\"\n\n  # Multiple filters\n  - name: us_revenue\n    agg: sum\n    sql: amount\n    filters:\n      - \"country = 'US'\"\n      - \"amount &gt; 0\"\n\n\n\n\nGraph-level metrics are defined at the top level and can reference model-level metrics or other graph-level metrics. Dependencies are auto-detected from SQL expressions.\n\n\nThe simplest graph-level metric just references a model-level metric:\nmetrics:\n  # Reference a model-level metric\n  - name: total_revenue\n    sql: orders.revenue\n    description: \"Total revenue from all orders\"\nNo type needed! Dependencies are automatically detected from the sql expression.\n\n\n\nmetrics:\n  - name: conversion_rate\n    type: ratio\n    numerator: orders.completed_revenue\n    denominator: orders.revenue\n\n\n\nDerived metrics use formulas and automatically detect dependencies:\nmetrics:\n  # Simple formula - dependencies auto-detected\n  - name: profit\n    type: derived\n    sql: \"revenue - cost\"\n\n  # References other metrics - no manual dependency list needed!\n  - name: revenue_per_customer\n    type: derived\n    sql: \"total_revenue / total_customers\"\n\n\n\nmetrics:\n  # Rolling window\n  - name: rolling_7day_revenue\n    type: cumulative\n    sql: orders.revenue\n    window: \"7 days\"\n\n  # Period-to-date (MTD, YTD, etc.)\n  - name: mtd_revenue\n    type: cumulative\n    sql: orders.revenue\n    grain_to_date: month\n\n\n\nmetrics:\n  - name: yoy_revenue_growth\n    type: time_comparison\n    base_metric: total_revenue\n    comparison_type: yoy          # yoy, mom, wow, qoq\n    calculation: percent_change   # percent_change, difference, ratio\n\n\n\nmetrics:\n  - name: signup_to_purchase_rate\n    type: conversion\n    entity: user_id\n    base_event: signup\n    conversion_event: purchase\n    conversion_window: \"7 days\"\n\n\n\n\nRelationships define how models join together. Use explicit relationship types instead of traditional join terminology.\nrelationships:\n  - name: string              # Required - name of related model\n    type: many_to_one|one_to_many|one_to_one  # Required\n    foreign_key: string       # Required - FK column name\n    primary_key: string       # Optional - PK in related table (defaults to related model's primary_key)\n\n\n\nmany_to_one: Many records in THIS table → one record in OTHER table (e.g., orders → customer)\none_to_many: One record in THIS table → many records in OTHER table (e.g., customer → orders)\none_to_one: One record in THIS table → one record in OTHER table (e.g., order → invoice)\n\n\n\n\nmodels:\n  # Orders: many orders belong to one customer\n  - name: orders\n    table: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id  # Column in orders table\n\n  # Customers: one customer has many orders\n  - name: customers\n    table: customers\n    primary_key: customer_id\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id  # Column in orders table (the OTHER table)\n\n  # Order has one invoice\n  - name: orders\n    relationships:\n      - name: invoice\n        type: one_to_one\n        foreign_key: order_id     # Column in invoice table\n\n\n\n\nparameters:\n  - name: string              # Required\n    type: string|number|date|unquoted|yesno  # Required\n    default_value: any        # Required\n    allowed_values: [any]     # Optional - restrict to specific values\n    description: string       # Optional\n\n\n\nstring: Text values (quoted in SQL)\nnumber: Numeric values (no quotes)\ndate: Date values (quoted as strings)\nunquoted: Raw SQL (table names, column names)\nyesno: Boolean mapped to yes/no\n\n\n\n\nparameters:\n  # Date\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\"\n\n  # Number\n  - name: min_amount\n    type: number\n    default_value: 100\n\n  # String with allowed values\n  - name: region\n    type: string\n    default_value: \"US\"\n    allowed_values: [\"US\", \"EU\", \"APAC\"]\n\n  # Boolean\n  - name: include_cancelled\n    type: yesno\n    default_value: false\n\n\n\n\n# yaml-language-server: $schema=./sidemantic-schema.json\n\nmodels:\n  - name: orders\n    table: public.orders\n    primary_key: order_id\n    description: \"Customer orders\"\n\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n    dimensions:\n      - name: status\n        type: categorical\n        sql: status\n\n      - name: order_date\n        type: time\n        sql: created_at\n        granularity: day\n\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n      - name: order_count\n        agg: count\n\n      - name: completed_revenue\n        agg: sum\n        sql: amount\n        filters: [\"status = 'completed'\"]\n\n  - name: customers\n    table: public.customers\n    primary_key: customer_id\n\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id\n\n    dimensions:\n      - name: region\n        type: categorical\n        sql: region\n\n    metrics:\n      - name: customer_count\n        agg: count_distinct\n        sql: customer_id\n\n# Graph-level metrics\nmetrics:\n  # Simple reference (dependencies auto-detected)\n  - name: total_revenue\n    sql: orders.revenue\n    description: \"Total revenue from all orders\"\n\n  # Ratio metric\n  - name: conversion_rate\n    type: ratio\n    numerator: orders.completed_revenue\n    denominator: orders.revenue\n    description: \"Percentage of revenue from completed orders\"\n\n  # Derived metric (dependencies auto-detected from formula)\n  - name: revenue_per_customer\n    type: derived\n    sql: \"total_revenue / customers.customer_count\"\n    description: \"Average revenue per customer\"\n\nparameters:\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\"\n\n  - name: min_amount\n    type: number\n    default_value: 100\n\n\n\nGenerate JSON Schema for editor autocomplete:\nuv run python -m sidemantic.schema\nAdd to your YAML file:\n# yaml-language-server: $schema=./sidemantic-schema.json\nThis enables autocomplete in VS Code, IntelliJ, and other editors with YAML Language Server support."
  },
  {
    "objectID": "YAML_FORMAT.html#file-structure",
    "href": "YAML_FORMAT.html#file-structure",
    "title": "YAML Format Reference",
    "section": "",
    "text": "# yaml-language-server: $schema=./sidemantic-schema.json\n\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    dimensions: [...]\n    metrics: [...]\n    relationships: [...]\n\nmetrics:\n  - name: total_revenue\n    sql: orders.revenue\n\nparameters:\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\""
  },
  {
    "objectID": "YAML_FORMAT.html#models",
    "href": "YAML_FORMAT.html#models",
    "title": "YAML Format Reference",
    "section": "",
    "text": "models:\n  - name: string              # Required - unique identifier\n    table: string             # Physical table (or use sql)\n    sql: string               # SQL query (or use table)\n    primary_key: string       # Required - primary key column\n    description: string       # Optional\n\n    dimensions: [...]         # Optional\n    metrics: [...]            # Optional (model-level aggregations)\n    relationships: [...]      # Optional"
  },
  {
    "objectID": "YAML_FORMAT.html#dimensions",
    "href": "YAML_FORMAT.html#dimensions",
    "title": "YAML Format Reference",
    "section": "",
    "text": "dimensions:\n  - name: string              # Required\n    type: categorical|time|boolean|numeric  # Required\n    sql: string               # SQL expression (defaults to name)\n    description: string       # Optional\n    label: string             # Optional\n\n    # For time dimensions only\n    granularity: hour|day|week|month|quarter|year\n\n\n\ncategorical: Text/enum values (status, region, product_name)\ntime: Dates/timestamps (order_date, created_at)\nboolean: True/false (is_active, is_deleted)\nnumeric: Numbers (price_tier, quantity_bucket)\n\n\n\n\ndimensions:\n  # Categorical\n  - name: status\n    type: categorical\n    sql: status\n\n  # Time with granularity\n  - name: order_date\n    type: time\n    sql: created_at\n    granularity: day\n\n  # Boolean\n  - name: is_active\n    type: boolean\n    sql: active\n\n  # SQL expression\n  - name: customer_tier\n    type: categorical\n    sql: |\n      CASE\n        WHEN amount &gt; 1000 THEN 'premium'\n        WHEN amount &gt; 100 THEN 'standard'\n        ELSE 'basic'\n      END"
  },
  {
    "objectID": "YAML_FORMAT.html#measures",
    "href": "YAML_FORMAT.html#measures",
    "title": "YAML Format Reference",
    "section": "",
    "text": "measures:\n  - name: string              # Required\n    agg: sum|count|count_distinct|avg|min|max|median  # Required\n    expr: string              # SQL expression (defaults to * for count)\n    filters: [string]         # Optional WHERE conditions\n    description: string       # Optional\n    fill_nulls_with: value    # Optional default for NULL\n\n\n\nmeasures:\n  # Ratio\n  - name: conversion_rate\n    type: ratio\n    numerator: completed_orders\n    denominator: total_orders\n\n  # Derived/Formula\n  - name: profit\n    type: derived\n    expr: \"revenue - cost\"\n\n  # Cumulative\n  - name: running_total\n    type: cumulative\n    expr: revenue\n    window: \"7 days\"              # Rolling window\n    # OR\n    grain_to_date: month          # MTD/YTD\n\n  # Time comparison\n  - name: yoy_growth\n    type: time_comparison\n    base_metric: revenue\n    comparison_type: yoy          # yoy, mom, wow, qoq\n    calculation: percent_change   # percent_change, difference, ratio\n\n  # Conversion funnel\n  - name: signup_to_purchase\n    type: conversion\n    entity: user_id\n    base_event: signup\n    conversion_event: purchase\n    conversion_window: \"7 days\"\n\n\n\nmeasures:\n  # Simple sum\n  - name: revenue\n    agg: sum\n    expr: amount\n\n  # Count\n  - name: order_count\n    agg: count\n\n  # Average\n  - name: avg_order_value\n    agg: avg\n    expr: amount\n\n  # With filter\n  - name: completed_revenue\n    agg: sum\n    expr: amount\n    filters: [\"status = 'completed'\"]\n\n  # SQL expression\n  - name: total_value\n    agg: sum\n    expr: \"quantity * price * (1 - discount)\"\n\n  # Multiple filters\n  - name: us_revenue\n    agg: sum\n    expr: amount\n    filters:\n      - \"country = 'US'\"\n      - \"amount &gt; 0\""
  },
  {
    "objectID": "YAML_FORMAT.html#joins",
    "href": "YAML_FORMAT.html#joins",
    "title": "YAML Format Reference",
    "section": "",
    "text": "joins:\n  - name: string              # Required - name of related model\n    type: belongs_to|has_many|has_one  # Required\n    foreign_key: string       # Required - FK column name\n\n\n\nbelongs_to: Foreign key is in THIS table\nhas_many: Foreign key is in OTHER table\nhas_one: Foreign key is in OTHER table (expects one record)\n\n\n\n\nmodels:\n  # Orders belong to customers\n  - name: orders\n    joins:\n      - name: customers\n        type: belongs_to\n        foreign_key: customer_id  # Column in orders table\n\n  # Customers have many orders\n  - name: customers\n    joins:\n      - name: orders\n        type: has_many\n        foreign_key: customer_id  # Column in orders table\n\n  # Order has one invoice\n  - name: orders\n    joins:\n      - name: invoice\n        type: has_one\n        foreign_key: order_id     # Column in invoice table"
  },
  {
    "objectID": "YAML_FORMAT.html#parameters",
    "href": "YAML_FORMAT.html#parameters",
    "title": "YAML Format Reference",
    "section": "",
    "text": "parameters:\n  - name: string              # Required\n    type: string|number|date|unquoted|yesno  # Required\n    default_value: any        # Required\n    allowed_values: [any]     # Optional - restrict to specific values\n    description: string       # Optional\n\n\n\nstring: Text values (quoted in SQL)\nnumber: Numeric values (no quotes)\ndate: Date values (quoted as strings)\nunquoted: Raw SQL (table names, column names)\nyesno: Boolean mapped to yes/no\n\n\n\n\nparameters:\n  # Date\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\"\n\n  # Number\n  - name: min_amount\n    type: number\n    default_value: 100\n\n  # String with allowed values\n  - name: region\n    type: string\n    default_value: \"US\"\n    allowed_values: [\"US\", \"EU\", \"APAC\"]\n\n  # Boolean\n  - name: include_cancelled\n    type: yesno\n    default_value: false"
  },
  {
    "objectID": "YAML_FORMAT.html#complete-example",
    "href": "YAML_FORMAT.html#complete-example",
    "title": "YAML Format Reference",
    "section": "",
    "text": "# yaml-language-server: $schema=./sidemantic-schema.json\n\nmodels:\n  - name: orders\n    table: public.orders\n    primary_key: order_id\n    description: \"Customer orders\"\n\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n    dimensions:\n      - name: status\n        type: categorical\n        sql: status\n\n      - name: order_date\n        type: time\n        sql: created_at\n        granularity: day\n\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n      - name: order_count\n        agg: count\n\n      - name: completed_revenue\n        agg: sum\n        sql: amount\n        filters: [\"status = 'completed'\"]\n\n  - name: customers\n    table: public.customers\n    primary_key: customer_id\n\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id\n\n    dimensions:\n      - name: region\n        type: categorical\n        sql: region\n\n    metrics:\n      - name: customer_count\n        agg: count_distinct\n        sql: customer_id\n\n# Graph-level metrics\nmetrics:\n  # Simple reference (dependencies auto-detected)\n  - name: total_revenue\n    sql: orders.revenue\n    description: \"Total revenue from all orders\"\n\n  # Ratio metric\n  - name: conversion_rate\n    type: ratio\n    numerator: orders.completed_revenue\n    denominator: orders.revenue\n    description: \"Percentage of revenue from completed orders\"\n\n  # Derived metric (dependencies auto-detected from formula)\n  - name: revenue_per_customer\n    type: derived\n    sql: \"total_revenue / customers.customer_count\"\n    description: \"Average revenue per customer\"\n\nparameters:\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\"\n\n  - name: min_amount\n    type: number\n    default_value: 100"
  },
  {
    "objectID": "YAML_FORMAT.html#json-schema",
    "href": "YAML_FORMAT.html#json-schema",
    "title": "YAML Format Reference",
    "section": "",
    "text": "Generate JSON Schema for editor autocomplete:\nuv run python -m sidemantic.schema\nAdd to your YAML file:\n# yaml-language-server: $schema=./sidemantic-schema.json\nThis enables autocomplete in VS Code, IntelliJ, and other editors with YAML Language Server support."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sidemantic",
    "section": "",
    "text": "Sidemantic is a semantic layer that lets you define metrics once and query them with SQL. It automatically handles joins, aggregations, and complex calculations.\n# Define once\nmodels:\n  - name: orders\n    table: orders\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n# Query anywhere with SQL\nlayer.sql(\"SELECT revenue FROM orders\")"
  },
  {
    "objectID": "index.html#what-is-sidemantic",
    "href": "index.html#what-is-sidemantic",
    "title": "Sidemantic",
    "section": "",
    "text": "Sidemantic is a semantic layer that lets you define metrics once and query them with SQL. It automatically handles joins, aggregations, and complex calculations.\n# Define once\nmodels:\n  - name: orders\n    table: orders\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n# Query anywhere with SQL\nlayer.sql(\"SELECT revenue FROM orders\")"
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Sidemantic",
    "section": "Key Features",
    "text": "Key Features\n\nCore Capabilities\n\nYAML definitions with JSON Schema for autocomplete\nSQL query interface - write familiar SQL, get semantic results\nAutomatic joins - define relationships once, query across models\nMulti-hop joins - automatic 2+ hop join path discovery\nAuto-detected dependencies - no manual dependency declarations needed!\nMulti-dialect - SQLGlot powers cross-database SQL generation\n\n\n\nRich Metric Types\n\nAggregations - sum, avg, count, count_distinct, min, max\nRatios - revenue / order_count\nDerived formulas - (revenue - cost) / revenue\nCumulative - running totals, rolling windows\nTime comparisons - YoY, MoM, WoW with LAG window functions\nConversion funnels - signup → purchase rate\n\n\n\nAdvanced Features\n\nSegments - reusable named filters with template placeholders\nMetric-level filters - auto-applied filters for business logic\nJinja2 templating - full conditionals and loops in SQL\nInheritance - extend models and metrics (DRY principles)\nHierarchies - parent/child dimensions with drill-down API\nRelative dates - “last 7 days”, “this month”, etc.\nUngrouped queries - raw row access without aggregation\n\n\n\nMetadata & Governance\n\nDisplay formatting - format strings and named formats (USD, percent)\nDrill fields - define drill-down paths for BI tools\nNon-additivity markers - prevent incorrect aggregation\nDefault dimensions - default time dimensions and granularity"
  },
  {
    "objectID": "index.html#quick-example",
    "href": "index.html#quick-example",
    "title": "Sidemantic",
    "section": "Quick Example",
    "text": "Quick Example\n# semantic_layer.yml\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n    dimensions:\n      - name: status\n        type: categorical\n        sql: status\n\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n# Graph-level metrics (dependencies auto-detected!)\nmetrics:\n  - name: total_revenue\n    sql: orders.revenue\nfrom sidemantic import SemanticLayer\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Query with SQL\nresult = layer.sql(\"\"\"\n    SELECT revenue, status\n    FROM orders\n    WHERE status = 'completed'\n\"\"\")\n\ndf = result.fetchdf()"
  },
  {
    "objectID": "index.html#learn-more",
    "href": "index.html#learn-more",
    "title": "Sidemantic",
    "section": "Learn More",
    "text": "Learn More\n\nGetting Started - Step-by-step tutorial\nExamples - Real-world examples\nYAML Reference - Complete YAML specification"
  },
  {
    "objectID": "models.html",
    "href": "models.html",
    "title": "Models",
    "section": "",
    "text": "Models define your data sources and their structure."
  },
  {
    "objectID": "models.html#basic-model",
    "href": "models.html#basic-model",
    "title": "Models",
    "section": "Basic Model",
    "text": "Basic Model\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\nOr in Python:\nfrom sidemantic import Model\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"order_id\"\n)"
  },
  {
    "objectID": "models.html#properties",
    "href": "models.html#properties",
    "title": "Models",
    "section": "Properties",
    "text": "Properties\n\nRequired\n\nname: Unique identifier for the model\ntable: Physical table name (or use sql for derived tables)\nprimary_key: Primary key column (required for joins and symmetric aggregates)\n\n\n\nOptional\n\nsql: SQL query instead of table name (for derived models)\ndescription: Human-readable description\nrelationships: Relationships to other models (see Relationships)\ndimensions: Attributes for grouping and filtering\nmetrics: Model-level aggregations"
  },
  {
    "objectID": "models.html#dimensions",
    "href": "models.html#dimensions",
    "title": "Models",
    "section": "Dimensions",
    "text": "Dimensions\nDimensions are attributes for grouping and filtering:\nmodels:\n  - name: orders\n    dimensions:\n      - name: status\n        type: categorical\n        sql: status\n\n      - name: order_date\n        type: time\n        sql: created_at\n        granularity: day\n\n      - name: is_weekend\n        type: boolean\n        sql: \"DAYOFWEEK(order_date) IN (6, 7)\"\n\n      - name: amount\n        type: numeric\n        sql: total_amount\n\nDimension Types\n\ncategorical: Text/enum values (status, region, product)\ntime: Dates/timestamps with granularity (day, week, month, year)\nboolean: True/false values\nnumeric: Numeric dimensions (price tier, quantity bucket)\n\n\n\nTime Granularity\n- name: order_date\n  type: time\n  sql: created_at\n  granularity: day  # hour, day, week, month, quarter, year\nQuery with: orders.order_date__month to automatically roll up to month."
  },
  {
    "objectID": "models.html#measures",
    "href": "models.html#measures",
    "title": "Models",
    "section": "Measures",
    "text": "Measures\nMeasures define aggregations:\nmodels:\n  - name: orders\n    measures:\n      # Simple aggregations\n      - name: revenue\n        agg: sum\n        expr: amount\n\n      - name: order_count\n        agg: count\n\n      - name: avg_order_value\n        agg: avg\n        expr: amount\n\n      # With filters\n      - name: completed_revenue\n        agg: sum\n        expr: amount\n        filters: [\"status = 'completed'\"]\n\n      # SQL expressions\n      - name: total_value\n        agg: sum\n        expr: \"quantity * price\"\n\nAggregation Types\n\nsum: Sum values\ncount: Count rows\ncount_distinct: Count unique values\navg: Average\nmin: Minimum value\nmax: Maximum value\nmedian: Median value\n\n\n\nComplex Measures\nMeasures can also be complex metrics:\nmeasures:\n  # Ratio\n  - name: conversion_rate\n    type: ratio\n    numerator: completed_orders\n    denominator: total_orders\n\n  # Formula\n  - name: profit_margin\n    type: derived\n    expr: \"(revenue - cost) / revenue\"\n\n  # Cumulative\n  - name: running_total\n    type: cumulative\n    expr: revenue\n    window: \"7 days\"\nSee Measures for complete details."
  },
  {
    "objectID": "models.html#derived-models",
    "href": "models.html#derived-models",
    "title": "Models",
    "section": "Derived Models",
    "text": "Derived Models\nUse SQL instead of a table:\nmodels:\n  - name: weekly_summary\n    sql: |\n      SELECT\n        DATE_TRUNC('week', order_date) as week,\n        SUM(amount) as total\n      FROM orders\n      GROUP BY 1\n    primary_key: week"
  },
  {
    "objectID": "models.html#complete-example",
    "href": "models.html#complete-example",
    "title": "Models",
    "section": "Complete Example",
    "text": "Complete Example\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    description: \"Customer orders\"\n\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n    dimensions:\n      - name: status\n        type: categorical\n        sql: status\n\n      - name: order_date\n        type: time\n        sql: created_at\n        granularity: day\n\n      - name: customer_tier\n        type: categorical\n        sql: |\n          CASE\n            WHEN total_amount &gt; 1000 THEN 'premium'\n            WHEN total_amount &gt; 100 THEN 'standard'\n            ELSE 'basic'\n          END\n\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n        description: \"Total order revenue\"\n\n      - name: order_count\n        agg: count\n        description: \"Number of orders\"\n\n      - name: avg_order_value\n        agg: avg\n        sql: amount\n\n      - name: completed_revenue\n        agg: sum\n        sql: amount\n        filters: [\"status = 'completed'\"]\n\n      - name: large_orders\n        agg: count\n        filters: [\"amount &gt; 1000\"]"
  },
  {
    "objectID": "models.html#best-practices",
    "href": "models.html#best-practices",
    "title": "Models",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipNaming Conventions\n\n\n\n\nModels: plural nouns (orders, customers)\nDimensions: descriptive names (status, order_date, customer_region)\nMetrics: what they measure (revenue, order_count, avg_order_value)\n\n\n\n\n\n\n\n\n\nWarningPrimary Keys Required\n\n\n\nAlways set primary_key - it’s required for: - Joins between models - Symmetric aggregates (fan-out handling) - Proper deduplication\n\n\n\n\n\n\n\n\nTipSQL Expressions\n\n\n\nUse SQL expressions in sql fields: - sql: \"UPPER(status)\" - transform dimension - sql: \"quantity * price\" - calculated metric - Supports any SQL your database supports"
  },
  {
    "objectID": "VIEW_DOCS.html",
    "href": "VIEW_DOCS.html",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "The easiest way to view the docs:\ncd docs\nuv run --with markdown python serve.py\nThis will: - Start a local server on http://localhost:8000 - Automatically open your browser - Convert .qmd files to HTML on the fly\nPress Ctrl+C to stop the server.\n\n\n\nFor the full Quarto experience with all features:\n\n\n# macOS\nbrew install --cask quarto\n\n# Or download from https://quarto.org/docs/get-started/\n\n\n\ncd docs\nquarto render\nquarto preview\nThis generates a complete static site in _site/.\n\n\n\n\nAll .qmd files are just markdown with YAML frontmatter. You can read them directly:\n# View in terminal\ncat docs/index.qmd\ncat docs/getting-started.qmd\ncat docs/features/parameters.qmd\n\n# Or open in your editor\ncode docs/\n\n\n\ndocs/\n├── index.qmd                    # Homepage\n├── getting-started.qmd          # Tutorial\n├── concepts/\n│   └── models.qmd              # Models guide\n├── features/\n│   ├── parameters.qmd          # Parameters\n│   └── symmetric-aggregates.qmd # Symmetric aggregates\n└── examples.qmd                # Code examples\n\n\n\n✅ 8 documentation files covering: - Getting started guide - Core concepts (Models) - Features (Parameters, Symmetric Aggregates) - Examples with runnable code - API patterns and best practices\n✅ 112 passing tests backing all documented features\n✅ 5 runnable examples in examples/ directory\n\n\n\nWhen viewing in the browser: - Home: Overview and quick start - Getting Started: Step-by-step tutorial - Models: Understanding the core abstraction - Parameters: Dynamic user input - Symmetric Aggregates: Preventing double-counting - Examples: Complete code samples\n\n\n\n\n\n# Kill existing server\npkill -f \"serve.py\"\n\n# Or use a different port\n# Edit serve.py and change PORT = 8000 to PORT = 8001\n\n\n\nuv pip install markdown\n\n\n\nManually navigate to: http://localhost:8000/index.qmd"
  },
  {
    "objectID": "VIEW_DOCS.html#quick-start---python-server-no-installation",
    "href": "VIEW_DOCS.html#quick-start---python-server-no-installation",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "The easiest way to view the docs:\ncd docs\nuv run --with markdown python serve.py\nThis will: - Start a local server on http://localhost:8000 - Automatically open your browser - Convert .qmd files to HTML on the fly\nPress Ctrl+C to stop the server."
  },
  {
    "objectID": "VIEW_DOCS.html#option-2-install-quarto-full-featured",
    "href": "VIEW_DOCS.html#option-2-install-quarto-full-featured",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "For the full Quarto experience with all features:\n\n\n# macOS\nbrew install --cask quarto\n\n# Or download from https://quarto.org/docs/get-started/\n\n\n\ncd docs\nquarto render\nquarto preview\nThis generates a complete static site in _site/."
  },
  {
    "objectID": "VIEW_DOCS.html#option-3-read-as-markdown",
    "href": "VIEW_DOCS.html#option-3-read-as-markdown",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "All .qmd files are just markdown with YAML frontmatter. You can read them directly:\n# View in terminal\ncat docs/index.qmd\ncat docs/getting-started.qmd\ncat docs/features/parameters.qmd\n\n# Or open in your editor\ncode docs/"
  },
  {
    "objectID": "VIEW_DOCS.html#documentation-structure",
    "href": "VIEW_DOCS.html#documentation-structure",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "docs/\n├── index.qmd                    # Homepage\n├── getting-started.qmd          # Tutorial\n├── concepts/\n│   └── models.qmd              # Models guide\n├── features/\n│   ├── parameters.qmd          # Parameters\n│   └── symmetric-aggregates.qmd # Symmetric aggregates\n└── examples.qmd                # Code examples"
  },
  {
    "objectID": "VIEW_DOCS.html#whats-included",
    "href": "VIEW_DOCS.html#whats-included",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "✅ 8 documentation files covering: - Getting started guide - Core concepts (Models) - Features (Parameters, Symmetric Aggregates) - Examples with runnable code - API patterns and best practices\n✅ 112 passing tests backing all documented features\n✅ 5 runnable examples in examples/ directory"
  },
  {
    "objectID": "VIEW_DOCS.html#navigation",
    "href": "VIEW_DOCS.html#navigation",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "When viewing in the browser: - Home: Overview and quick start - Getting Started: Step-by-step tutorial - Models: Understanding the core abstraction - Parameters: Dynamic user input - Symmetric Aggregates: Preventing double-counting - Examples: Complete code samples"
  },
  {
    "objectID": "VIEW_DOCS.html#troubleshooting",
    "href": "VIEW_DOCS.html#troubleshooting",
    "title": "Viewing Sidemantic Documentation",
    "section": "",
    "text": "# Kill existing server\npkill -f \"serve.py\"\n\n# Or use a different port\n# Edit serve.py and change PORT = 8000 to PORT = 8001\n\n\n\nuv pip install markdown\n\n\n\nManually navigate to: http://localhost:8000/index.qmd"
  },
  {
    "objectID": "GOTCHAS.html",
    "href": "GOTCHAS.html",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "This document covers common pitfalls and their solutions when working with Sidemantic.\n\n\n\n\n# WRONG - creates double quotes\nfilters = [f\"orders.order_date &gt;= '{{{{ start_date }}}}'\"]\n# Result: orders.order_date &gt;= ''2024-01-01'' (BREAKS!)\n\n# CORRECT\nfilters = [\"orders.order_date &gt;= {{ start_date }}\"]\n# Result: orders.order_date &gt;= '2024-01-01' ✓\nWhy: Parameters are automatically formatted with quotes based on their type. Adding extra quotes creates ''value'' which SQLGlot can’t parse.\nParameter formatting: - string: Adds quotes → 'value' - date: Adds quotes → '2024-01-01' - number: No quotes → 100 - unquoted: No quotes → table_name\n\n\n\n# WRONG - customers table not in query\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],  # Only orders\n    dimensions=[],               # Only orders\n    filters=[\"customers.region = 'US'\"]  # References customers!\n)\n# Error: Table \"customers\" not found\nWhy: Sidemantic only joins tables when they’re needed (referenced in metrics or dimensions). If you filter on a table that’s not joined, the query fails.\nSolutions:\n\nAdd a dimension from the filtered table:\n\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"customers.region\"],  # Forces customers join\n    filters=[\"customers.region = 'US'\"]\n)\n\nConditionally build filters:\n\ndef build_filters(include_customers=False):\n    filters = [\"orders.order_date &gt;= '2024-01-01'\"]\n    if include_customers:\n        filters.append(\"customers.region = 'US'\")\n    return filters\n\n# Query without customers\nsql1 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    filters=build_filters(include_customers=False)\n)\n\n# Query with customers\nsql2 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"customers.region\"],\n    filters=build_filters(include_customers=True)\n)\n\n\n\n\n\n\nFilters are parsed and transformed:\n# Input filter\n\"orders.order_date &gt;= '2024-01-01'\"\n\n# After parameter interpolation\n\"orders.order_date &gt;= '2024-01-01'\"\n\n# After field replacement (adds CTE prefix, handles measures)\n\"orders_cte.order_date &gt;= '2024-01-01'\"\nPotential issues: - Complex SQL expressions might not parse correctly - Subqueries in filters are not supported - Regex replacement can match inside strings (we fixed this but it’s fragile)\nWorkaround for complex filters: Use metrics with filters instead:\n# Instead of complex filter\nfilters = [\"CASE WHEN orders.status = 'X' THEN ... END\"]\n\n# Create a filtered measure\nMeasure(\n    name=\"filtered_revenue\",\n    agg=\"sum\",\n    expr=\"amount\",\n    filters=[\"status = 'completed'\"]\n)\n\n\n\n\n\n\n# Single one-to-many join - NO symmetric aggregates\nsql = generator.generate(\n    metrics=[\"orders.revenue\", \"order_items.quantity\"]\n)\n# Uses: SUM(orders_cte.revenue_raw) - regular sum\n\n# Multiple one-to-many joins - YES symmetric aggregates\nsql = generator.generate(\n    metrics=[\"orders.revenue\", \"order_items.quantity\", \"shipments.count\"]\n)\n# Uses: SUM(DISTINCT HASH(...) + revenue) - symmetric aggregates\nWhy: Symmetric aggregates only apply when you have ≥2 one-to-many joins creating fan-out. With a single join, regular aggregation is correct and faster.\nTo verify:\nsql = generator.generate(...)\nprint(sql)\n# Look for: HASH(primary_key) in the SQL\n\n\n\n\n\n\n# WRONG\norders = Model(\n    name=\"orders\",\n    joins=[\n        # has_many: foreign_key is on the OTHER table\n        Join(name=\"order_items\", type=\"has_many\", foreign_key=\"id\")  # WRONG!\n    ]\n)\n\n# CORRECT\norders = Model(\n    name=\"orders\",\n    joins=[\n        # has_many: foreign_key is the column in order_items table\n        Join(name=\"order_items\", type=\"has_many\", foreign_key=\"order_id\")\n    ]\n)\n\norder_items = Model(\n    name=\"order_items\",\n    joins=[\n        # belongs_to: foreign_key is the column in THIS table\n        Join(name=\"orders\", type=\"belongs_to\", foreign_key=\"order_id\")\n    ]\n)\nRule of thumb: - has_many: foreign_key is in the other (child) table - belongs_to: foreign_key is in this table - has_one: foreign_key is in the other table (like has_many but unique)\n\n\n\n\n\n\n# WRONG - no primary key\norders = Model(\n    name=\"orders\",\n    # primary_key missing!\n)\n\n# Result: Symmetric aggregates won't work\n# Result: Defaults to \"id\" which might not exist\nWhy: Symmetric aggregates require primary_key to hash for deduplication.\n# CORRECT\norders = Model(\n    name=\"orders\",\n    primary_key=\"id\",  # or whatever your PK is\n)\n\n\n\n\n\n\n# WRONG\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\"],\n    order_by=[\"orders.order_date\"]  # Full reference\n)\n# Error: Table \"orders\" not found (it's \"orders_cte\")\n# CORRECT\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\"],\n    order_by=[\"order_date\"]  # Just column name\n)\nWhy: ORDER BY uses the column alias from SELECT, not the table reference.\n\n\n\n\n\n\nCause: Filtering on a table that’s not joined. Fix: Add a dimension from that table, or remove the filter.\n\n\n\nCause: Trying to reference a measure directly. Fix: Measures are stored as {name}_raw in CTEs. Use measures in metrics, not in custom SQL.\n\n\n\nCause: Parameter produced invalid SQL (usually quoting issue). Fix: Don’t add quotes around { param } placeholders.\n\n\n\nCause: Symmetric aggregate hash overflow (old bug, should be fixed). Fix: We use HUGEINT now, but if this happens, check DuckDB version.\n\n\n\n\n\n\nCheck:\n# See if you actually need all those joins\nsql = generator.generate(\n    metrics=[\"orders.revenue\", \"items.qty\", \"shipments.count\", \"notes.count\"]\n)\n# 3 one-to-many joins = slow!\nConsider: 1. Pre-aggregate in separate queries 2. Use materialized views in your database 3. Denormalize your data model 4. Query subsets separately and combine in application\n\n\n\n\n\n\nsql = generator.generate(...)\nprint(sql)  # Always check the actual SQL!\n\n\n\nif \"HASH(\" in sql:\n    print(\"Using symmetric aggregates\")\nelse:\n    print(\"Using regular aggregation\")\n\n\n\nif \"LEFT JOIN customers_cte\" in sql:\n    print(\"Customers table is joined\")\n\n\n\n# Start simple\nsql1 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\"]\n)\n\n# Add complexity gradually\nsql2 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\", \"customers.region\"]\n)\n\n# Add filters last\nsql3 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\", \"customers.region\"],\n    filters=[\"customers.region = 'US'\"]\n)\n\n\n\n\n\nAlways read the generated SQL - Don’t trust, verify\nStart simple - Add complexity incrementally\nUse parameters correctly - Don’t add quotes around placeholders\nMatch filters to data - Only filter on tables that are joined\nSet primary keys - Required for symmetric aggregates\nTest with real data - Edge cases matter\nCheck performance - EXPLAIN ANALYZE your queries\nUse descriptive names - Future you will thank you\n\n\n\n\nIf you’re stuck:\n\nPrint the generated SQL and look for obvious errors\nRun the SQL directly in DuckDB/your database\nCheck if tables referenced in filters are actually joined\nVerify parameter interpolation with simple test cases\nCheck the test suite for similar examples\n\n\n\n\nSee these working examples:\n\nexamples/parameters_example.py - Correct parameter usage\nexamples/symmetric_aggregates_example.py - Fan-out handling\nexamples/streamlit_dashboard.py - Complete interactive app\ntests/test_parameters.py - Parameter test cases\ntests/test_symmetric_aggregates.py - Join test cases"
  },
  {
    "objectID": "GOTCHAS.html#parameters-and-filters",
    "href": "GOTCHAS.html#parameters-and-filters",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "# WRONG - creates double quotes\nfilters = [f\"orders.order_date &gt;= '{{{{ start_date }}}}'\"]\n# Result: orders.order_date &gt;= ''2024-01-01'' (BREAKS!)\n\n# CORRECT\nfilters = [\"orders.order_date &gt;= {{ start_date }}\"]\n# Result: orders.order_date &gt;= '2024-01-01' ✓\nWhy: Parameters are automatically formatted with quotes based on their type. Adding extra quotes creates ''value'' which SQLGlot can’t parse.\nParameter formatting: - string: Adds quotes → 'value' - date: Adds quotes → '2024-01-01' - number: No quotes → 100 - unquoted: No quotes → table_name\n\n\n\n# WRONG - customers table not in query\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],  # Only orders\n    dimensions=[],               # Only orders\n    filters=[\"customers.region = 'US'\"]  # References customers!\n)\n# Error: Table \"customers\" not found\nWhy: Sidemantic only joins tables when they’re needed (referenced in metrics or dimensions). If you filter on a table that’s not joined, the query fails.\nSolutions:\n\nAdd a dimension from the filtered table:\n\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"customers.region\"],  # Forces customers join\n    filters=[\"customers.region = 'US'\"]\n)\n\nConditionally build filters:\n\ndef build_filters(include_customers=False):\n    filters = [\"orders.order_date &gt;= '2024-01-01'\"]\n    if include_customers:\n        filters.append(\"customers.region = 'US'\")\n    return filters\n\n# Query without customers\nsql1 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    filters=build_filters(include_customers=False)\n)\n\n# Query with customers\nsql2 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"customers.region\"],\n    filters=build_filters(include_customers=True)\n)"
  },
  {
    "objectID": "GOTCHAS.html#filter-parsing",
    "href": "GOTCHAS.html#filter-parsing",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "Filters are parsed and transformed:\n# Input filter\n\"orders.order_date &gt;= '2024-01-01'\"\n\n# After parameter interpolation\n\"orders.order_date &gt;= '2024-01-01'\"\n\n# After field replacement (adds CTE prefix, handles measures)\n\"orders_cte.order_date &gt;= '2024-01-01'\"\nPotential issues: - Complex SQL expressions might not parse correctly - Subqueries in filters are not supported - Regex replacement can match inside strings (we fixed this but it’s fragile)\nWorkaround for complex filters: Use metrics with filters instead:\n# Instead of complex filter\nfilters = [\"CASE WHEN orders.status = 'X' THEN ... END\"]\n\n# Create a filtered measure\nMeasure(\n    name=\"filtered_revenue\",\n    agg=\"sum\",\n    expr=\"amount\",\n    filters=[\"status = 'completed'\"]\n)"
  },
  {
    "objectID": "GOTCHAS.html#symmetric-aggregates",
    "href": "GOTCHAS.html#symmetric-aggregates",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "# Single one-to-many join - NO symmetric aggregates\nsql = generator.generate(\n    metrics=[\"orders.revenue\", \"order_items.quantity\"]\n)\n# Uses: SUM(orders_cte.revenue_raw) - regular sum\n\n# Multiple one-to-many joins - YES symmetric aggregates\nsql = generator.generate(\n    metrics=[\"orders.revenue\", \"order_items.quantity\", \"shipments.count\"]\n)\n# Uses: SUM(DISTINCT HASH(...) + revenue) - symmetric aggregates\nWhy: Symmetric aggregates only apply when you have ≥2 one-to-many joins creating fan-out. With a single join, regular aggregation is correct and faster.\nTo verify:\nsql = generator.generate(...)\nprint(sql)\n# Look for: HASH(primary_key) in the SQL"
  },
  {
    "objectID": "GOTCHAS.html#join-relationships",
    "href": "GOTCHAS.html#join-relationships",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "# WRONG\norders = Model(\n    name=\"orders\",\n    joins=[\n        # has_many: foreign_key is on the OTHER table\n        Join(name=\"order_items\", type=\"has_many\", foreign_key=\"id\")  # WRONG!\n    ]\n)\n\n# CORRECT\norders = Model(\n    name=\"orders\",\n    joins=[\n        # has_many: foreign_key is the column in order_items table\n        Join(name=\"order_items\", type=\"has_many\", foreign_key=\"order_id\")\n    ]\n)\n\norder_items = Model(\n    name=\"order_items\",\n    joins=[\n        # belongs_to: foreign_key is the column in THIS table\n        Join(name=\"orders\", type=\"belongs_to\", foreign_key=\"order_id\")\n    ]\n)\nRule of thumb: - has_many: foreign_key is in the other (child) table - belongs_to: foreign_key is in this table - has_one: foreign_key is in the other table (like has_many but unique)"
  },
  {
    "objectID": "GOTCHAS.html#sql-generation",
    "href": "GOTCHAS.html#sql-generation",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "# WRONG - no primary key\norders = Model(\n    name=\"orders\",\n    # primary_key missing!\n)\n\n# Result: Symmetric aggregates won't work\n# Result: Defaults to \"id\" which might not exist\nWhy: Symmetric aggregates require primary_key to hash for deduplication.\n# CORRECT\norders = Model(\n    name=\"orders\",\n    primary_key=\"id\",  # or whatever your PK is\n)"
  },
  {
    "objectID": "GOTCHAS.html#order-by",
    "href": "GOTCHAS.html#order-by",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "# WRONG\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\"],\n    order_by=[\"orders.order_date\"]  # Full reference\n)\n# Error: Table \"orders\" not found (it's \"orders_cte\")\n# CORRECT\nsql = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\"],\n    order_by=[\"order_date\"]  # Just column name\n)\nWhy: ORDER BY uses the column alias from SELECT, not the table reference."
  },
  {
    "objectID": "GOTCHAS.html#common-error-messages",
    "href": "GOTCHAS.html#common-error-messages",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "Cause: Filtering on a table that’s not joined. Fix: Add a dimension from that table, or remove the filter.\n\n\n\nCause: Trying to reference a measure directly. Fix: Measures are stored as {name}_raw in CTEs. Use measures in metrics, not in custom SQL.\n\n\n\nCause: Parameter produced invalid SQL (usually quoting issue). Fix: Don’t add quotes around { param } placeholders.\n\n\n\nCause: Symmetric aggregate hash overflow (old bug, should be fixed). Fix: We use HUGEINT now, but if this happens, check DuckDB version."
  },
  {
    "objectID": "GOTCHAS.html#performance",
    "href": "GOTCHAS.html#performance",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "Check:\n# See if you actually need all those joins\nsql = generator.generate(\n    metrics=[\"orders.revenue\", \"items.qty\", \"shipments.count\", \"notes.count\"]\n)\n# 3 one-to-many joins = slow!\nConsider: 1. Pre-aggregate in separate queries 2. Use materialized views in your database 3. Denormalize your data model 4. Query subsets separately and combine in application"
  },
  {
    "objectID": "GOTCHAS.html#debugging",
    "href": "GOTCHAS.html#debugging",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "sql = generator.generate(...)\nprint(sql)  # Always check the actual SQL!\n\n\n\nif \"HASH(\" in sql:\n    print(\"Using symmetric aggregates\")\nelse:\n    print(\"Using regular aggregation\")\n\n\n\nif \"LEFT JOIN customers_cte\" in sql:\n    print(\"Customers table is joined\")\n\n\n\n# Start simple\nsql1 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\"]\n)\n\n# Add complexity gradually\nsql2 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\", \"customers.region\"]\n)\n\n# Add filters last\nsql3 = generator.generate(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_date\", \"customers.region\"],\n    filters=[\"customers.region = 'US'\"]\n)"
  },
  {
    "objectID": "GOTCHAS.html#best-practices",
    "href": "GOTCHAS.html#best-practices",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "Always read the generated SQL - Don’t trust, verify\nStart simple - Add complexity incrementally\nUse parameters correctly - Don’t add quotes around placeholders\nMatch filters to data - Only filter on tables that are joined\nSet primary keys - Required for symmetric aggregates\nTest with real data - Edge cases matter\nCheck performance - EXPLAIN ANALYZE your queries\nUse descriptive names - Future you will thank you"
  },
  {
    "objectID": "GOTCHAS.html#getting-help",
    "href": "GOTCHAS.html#getting-help",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "If you’re stuck:\n\nPrint the generated SQL and look for obvious errors\nRun the SQL directly in DuckDB/your database\nCheck if tables referenced in filters are actually joined\nVerify parameter interpolation with simple test cases\nCheck the test suite for similar examples"
  },
  {
    "objectID": "GOTCHAS.html#examples-that-work",
    "href": "GOTCHAS.html#examples-that-work",
    "title": "Common Gotchas and Solutions",
    "section": "",
    "text": "See these working examples:\n\nexamples/parameters_example.py - Correct parameter usage\nexamples/symmetric_aggregates_example.py - Fan-out handling\nexamples/streamlit_dashboard.py - Complete interactive app\ntests/test_parameters.py - Parameter test cases\ntests/test_symmetric_aggregates.py - Join test cases"
  },
  {
    "objectID": "sql-queries.html",
    "href": "sql-queries.html",
    "title": "SQL Queries",
    "section": "",
    "text": "Query the semantic layer with familiar SQL syntax."
  },
  {
    "objectID": "sql-queries.html#basic-queries",
    "href": "sql-queries.html#basic-queries",
    "title": "SQL Queries",
    "section": "Basic Queries",
    "text": "Basic Queries\nlayer.sql(\"SELECT revenue FROM orders\")\n\nlayer.sql(\"\"\"\n    SELECT revenue, status\n    FROM orders\n    WHERE status = 'completed'\n\"\"\")"
  },
  {
    "objectID": "sql-queries.html#supported-features",
    "href": "sql-queries.html#supported-features",
    "title": "SQL Queries",
    "section": "Supported Features",
    "text": "Supported Features\n\nSELECT\nSelect measures and dimensions:\nSELECT revenue, order_count, status\nFROM orders\nTable prefixes optional (inferred from FROM):\n-- Both work\nSELECT orders.revenue FROM orders\nSELECT revenue FROM orders\n\n\nWHERE\nFilter with standard SQL conditions:\nSELECT revenue\nFROM orders\nWHERE status = 'completed'\n  AND order_date &gt;= '2024-01-01'\n  AND amount &gt; 100\n\n\nORDER BY\nSELECT revenue, status\nFROM orders\nORDER BY revenue DESC, status ASC\n\n\nLIMIT / OFFSET\nSELECT revenue FROM orders LIMIT 10\n\nSELECT revenue FROM orders LIMIT 10 OFFSET 5\n\n\nCross-Model Queries\nReference multiple models - joins happen automatically:\nSELECT\n    orders.revenue,\n    customers.region,\n    regions.country\nFROM orders\n\n\nSELECT *\nExpands to all dimensions and measures:\nSELECT * FROM orders\n-- Expands to all dimensions + measures in orders model"
  },
  {
    "objectID": "sql-queries.html#parameters",
    "href": "sql-queries.html#parameters",
    "title": "SQL Queries",
    "section": "Parameters",
    "text": "Parameters\nUse { param } syntax:\nlayer.sql(\n    \"\"\"\n    SELECT revenue\n    FROM orders\n    WHERE order_date &gt;= {{ start_date }}\n      AND region = {{ region }}\n    \"\"\",\n    parameters={\n        \"start_date\": \"2024-01-01\",\n        \"region\": \"US\"\n    }\n)\n\n\n\n\n\n\nWarningDon’t Quote Parameters\n\n\n\nParameters are automatically quoted based on type: - ❌ WHERE date &gt;= '{{ start_date }}' (creates ''2024-01-01'') - ✅ WHERE date &gt;= {{ start_date }}"
  },
  {
    "objectID": "sql-queries.html#limitations",
    "href": "sql-queries.html#limitations",
    "title": "SQL Queries",
    "section": "Limitations",
    "text": "Limitations\nThese SQL features are NOT supported:\n\nNo Explicit JOINs\n❌ Can’t write:\nSELECT *\nFROM orders\nJOIN customers ON orders.customer_id = customers.id\n✅ Instead:\n-- Just reference both models - joins happen automatically\nSELECT orders.revenue, customers.name\nFROM orders\n\n\nNo GROUP BY\n❌ Can’t write:\nSELECT status, SUM(amount)\nFROM orders\nGROUP BY status\n✅ Instead:\n-- Grouping is automatic based on dimensions\nSELECT revenue, status\nFROM orders\n\n\nNo Aggregate Functions\n❌ Can’t write:\nSELECT COUNT(*), SUM(amount)\nFROM orders\n✅ Instead, define measures:\nmetrics:\n  - name: order_count\n    agg: count\n  - name: revenue\n    agg: sum\n    sql: amount\nThen:\nSELECT order_count, revenue FROM orders\n\n\nNo Subqueries\n❌ Can’t write:\nSELECT * FROM (\n    SELECT revenue FROM orders\n) AS subquery\n\n\nNo CTEs/WITH\n❌ Can’t write:\nWITH temp AS (SELECT * FROM orders)\nSELECT * FROM temp\n\n\nNo HAVING\n❌ Can’t write:\nSELECT status, revenue\nFROM orders\nHAVING revenue &gt; 1000\n✅ Use WHERE on measures instead:\nSELECT status, revenue\nFROM orders\nWHERE revenue &gt; 1000  -- This works!\n\n\nNo Window Functions\n❌ Can’t write:\nSELECT revenue, ROW_NUMBER() OVER (PARTITION BY status)\nFROM orders\n✅ Use table calculations or cumulative measures instead.\n\n\nNo DISTINCT\n❌ Can’t write:\nSELECT DISTINCT status FROM orders\n✅ Just select the dimension:\nSELECT status FROM orders\n\n\nNo UNION/INTERSECT/EXCEPT\n❌ Set operations not supported.\n\n\nNo INSERT/UPDATE/DELETE\nRead-only semantic layer."
  },
  {
    "objectID": "sql-queries.html#why-these-limitations",
    "href": "sql-queries.html#why-these-limitations",
    "title": "SQL Queries",
    "section": "Why These Limitations?",
    "text": "Why These Limitations?\nThe semantic layer rewrites your SQL to use pre-defined measures and handle joins automatically. This means:\n\nMeasures must be pre-defined - No ad-hoc SUM() in SELECT\nJoins are automatic - Based on model relationships\nGrouping is automatic - Based on dimensions selected\n\nThis trade-off ensures: - ✅ Consistent metric definitions - ✅ Automatic join handling - ✅ Symmetric aggregate deduplication - ✅ Centralized business logic"
  },
  {
    "objectID": "sql-queries.html#best-practices",
    "href": "sql-queries.html#best-practices",
    "title": "SQL Queries",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipDefine Once, Query Anywhere\n\n\n\nDefine metrics in YAML:\nmetrics:\n  - name: revenue\n    agg: sum\n    sql: amount\nThen query with simple SQL:\nSELECT revenue FROM orders\n\n\n\n\n\n\n\n\nTipComplex Logic in Measures\n\n\n\nPut complex logic in measure definitions, not queries:\n# Define complex measure\nmetrics:\n  - name: high_value_revenue\n    agg: sum\n    sql: \"CASE WHEN amount &gt; 1000 THEN amount ELSE 0 END\"\n-- Simple query\nSELECT high_value_revenue FROM orders\n\n\n\n\n\n\n\n\nWarningFilter on Joined Tables\n\n\n\nOnly filter on tables that are actually joined:\n❌ This fails (customers not joined):\nSELECT orders.revenue\nWHERE customers.region = 'US'\n✅ Include a dimension to force join:\nSELECT orders.revenue, customers.region\nWHERE customers.region = 'US'"
  },
  {
    "objectID": "sql-queries.html#programmatic-alternative",
    "href": "sql-queries.html#programmatic-alternative",
    "title": "SQL Queries",
    "section": "Programmatic Alternative",
    "text": "Programmatic Alternative\nFor full flexibility, use the programmatic API:\nresult = layer.query(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.status\"],\n    filters=[\"orders.status = 'completed'\"],\n    order_by=[\"orders.revenue DESC\"],\n    limit=10\n)\nOr generate SQL and execute yourself:\nsql = layer.compile(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.status\"]\n)\n\n# Modify as needed\nsql += \" UNION SELECT ...\"\n\n# Execute directly\nconn.execute(sql)"
  },
  {
    "objectID": "python-api.html",
    "href": "python-api.html",
    "title": "Python API",
    "section": "",
    "text": "Complete Python API reference."
  },
  {
    "objectID": "python-api.html#semanticlayer",
    "href": "python-api.html#semanticlayer",
    "title": "Python API",
    "section": "SemanticLayer",
    "text": "SemanticLayer\nMain entry point:\nfrom sidemantic import SemanticLayer\n\n# Create\nlayer = SemanticLayer()\n\n# From YAML\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# With custom connection\nlayer = SemanticLayer(connection=\"duckdb:///data.db\")\n\nMethods\n\nquery()\nExecute a query and return results:\nresult = layer.query(\n    metrics=[\"orders.revenue\", \"orders.order_count\"],\n    dimensions=[\"orders.status\"],\n    filters=[\"orders.status = 'completed'\"],\n    segments=[\"orders.high_value\"],  # Named filters\n    order_by=[\"orders.revenue DESC\"],\n    limit=10,\n    offset=5,\n    ungrouped=False,  # Set True for raw rows\n    parameters={\"start_date\": \"2024-01-01\"}\n)\n\ndf = result.fetchdf()  # Get DataFrame\n\n\nsql()\nQuery with SQL:\nresult = layer.sql(\"\"\"\n    SELECT revenue, status\n    FROM orders\n    WHERE status = 'completed'\n    LIMIT 10\n\"\"\")\n\ndf = result.fetchdf()\nWith parameters:\nresult = layer.sql(\n    \"SELECT revenue FROM orders WHERE order_date &gt;= {{ start_date }}\",\n    parameters={\"start_date\": \"2024-01-01\"}\n)\n\n\ncompile()\nGenerate SQL without executing:\nsql = layer.compile(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.status\"],\n    filters=[\"orders.status = 'completed'\"],\n    segments=[\"orders.completed\"],\n    ungrouped=False,\n    parameters={\"min_amount\": 100}\n)\n\nprint(sql)\n\n\nadd_model()\nAdd a model:\nfrom sidemantic import Model, Dimension, Metric\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n    dimensions=[...],\n    metrics=[...]\n)\n\nlayer.add_model(orders)\n\n\nadd_metric()\nAdd a top-level metric:\nfrom sidemantic import Metric\n\ntotal_revenue = Metric(\n    name=\"total_revenue\",\n    expr=\"orders.revenue\"\n)\n\nlayer.add_metric(total_revenue)\n\n\nfrom_yaml() / to_yaml()\nLoad/save YAML:\n# Load\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Save\nlayer.to_yaml(\"output.yml\")"
  },
  {
    "objectID": "python-api.html#model",
    "href": "python-api.html#model",
    "title": "Python API",
    "section": "Model",
    "text": "Model\nDefine a data model:\nfrom sidemantic import Model, Dimension, Metric, Relationship, Segment\n\nmodel = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n    description=\"Customer orders\",\n    extends=\"base_model\",  # Inherit from parent model\n\n    dimensions=[\n        Dimension(name=\"status\", type=\"categorical\", expr=\"status\"),\n        Dimension(name=\"order_date\", type=\"time\", expr=\"created_at\", granularity=\"day\")\n    ],\n\n    metrics=[\n        Metric(name=\"revenue\", agg=\"sum\", expr=\"amount\"),\n        Metric(name=\"order_count\", agg=\"count\")\n    ],\n\n    segments=[\n        Segment(name=\"completed\", sql=\"{model}.status = 'completed'\"),\n        Segment(name=\"high_value\", sql=\"{model}.amount &gt;= 500\")\n    ],\n\n    relationships=[\n        Relationship(name=\"customers\", type=\"many_to_one\", foreign_key=\"customer_id\")\n    ]\n)\n\nProperties\n\nname: Unique identifier\ntable: Physical table name (or use sql)\nsql: SQL query for derived models\nprimary_key: Primary key column (default: “id”)\nextends: Parent model to inherit from\ndimensions: List of Dimension objects\nmetrics: List of Metric objects\nsegments: List of Segment objects (named filters)\nrelationships: List of Relationship objects\ndescription: Human-readable description\n\n\n\nHierarchy Methods\n# Get full hierarchy path for a dimension\npath = model.get_hierarchy_path(\"city\")  # ['country', 'state', 'city']\n\n# Get next level down\nchild = model.get_drill_down(\"state\")  # 'city'\n\n# Get level up\nparent = model.get_drill_up(\"city\")  # 'state'"
  },
  {
    "objectID": "python-api.html#dimension",
    "href": "python-api.html#dimension",
    "title": "Python API",
    "section": "Dimension",
    "text": "Dimension\nDefine a dimension:\nfrom sidemantic import Dimension\n\n# Categorical\nstatus = Dimension(\n    name=\"status\",\n    type=\"categorical\",\n    expr=\"status\"\n)\n\n# Time\norder_date = Dimension(\n    name=\"order_date\",\n    type=\"time\",\n    expr=\"created_at\",\n    granularity=\"day\"\n)\n\n# Boolean\nis_active = Dimension(\n    name=\"is_active\",\n    type=\"boolean\",\n    expr=\"active\"\n)\n\n# Numeric\ntier = Dimension(\n    name=\"tier\",\n    type=\"numeric\",\n    expr=\"customer_tier\"\n)\n\n# With hierarchy\ncity = Dimension(\n    name=\"city\",\n    type=\"categorical\",\n    expr=\"city\",\n    parent=\"state\"  # For drill-down hierarchies\n)\n\n# With formatting\nrevenue_formatted = Dimension(\n    name=\"revenue\",\n    type=\"numeric\",\n    expr=\"amount\",\n    format=\"$#,##0.00\",\n    value_format_name=\"usd\"\n)\n\nProperties\n\nname: Unique identifier\ntype: categorical, time, boolean, or numeric\nexpr: SQL expression (defaults to name)\ngranularity: For time dimensions: hour, day, week, month, quarter, year\nparent: Parent dimension name for hierarchies\nformat: Display format string (e.g., \"$#,##0.00\", \"0.00%\")\nvalue_format_name: Named format (e.g., \"usd\", \"percent\", \"decimal_2\")\ndescription: Human-readable description"
  },
  {
    "objectID": "python-api.html#measure",
    "href": "python-api.html#measure",
    "title": "Python API",
    "section": "Measure",
    "text": "Measure\nDefine a measure:\nfrom sidemantic import Metric\n\n# Simple aggregation\nrevenue = Measure(\n    name=\"revenue\",\n    agg=\"sum\",\n    sql=\"amount\"\n)\n\n# With filter\ncompleted_revenue = Measure(\n    name=\"completed_revenue\",\n    agg=\"sum\",\n    sql=\"amount\",\n    filters=[\"status = 'completed'\"]\n)\n\n# Ratio\nconversion_rate = Measure(\n    name=\"conversion_rate\",\n    type=\"ratio\",\n    numerator=\"completed_orders\",\n    denominator=\"total_orders\"\n)\n\n# Derived\nprofit = Measure(\n    name=\"profit\",\n    type=\"derived\",\n    sql=\"revenue - cost\"\n)\n\n# Cumulative\nrunning_total = Measure(\n    name=\"running_total\",\n    type=\"cumulative\",\n    sql=\"revenue\",\n    window=\"7 days\"\n)\n\n# Time comparison\nyoy_growth = Measure(\n    name=\"yoy_growth\",\n    type=\"time_comparison\",\n    base_metric=\"revenue\",\n    comparison_type=\"yoy\",\n    calculation=\"percent_change\"\n)\n\nProperties\n\nSimple Aggregations\n\nname: Unique identifier\nagg: sum, count, count_distinct, avg, min, max, median\nexpr: SQL expression (defaults to * for count)\nfilters: List of WHERE conditions\ndescription: Human-readable description\n\n\n\nRatio Measures\n\ntype: \"ratio\"\nnumerator: Numerator measure name\ndenominator: Denominator measure name\noffset_window: Time offset for denominator (e.g., \"1 month\")\n\n\n\nDerived Measures\n\ntype: \"derived\"\nexpr: Formula expression\n\n\n\nCumulative Measures\n\ntype: \"cumulative\"\nexpr: Base measure name\nwindow: Rolling window (e.g., \"7 days\")\ngrain_to_date: Period-to-date (day, week, month, quarter, year)\n\n\n\nTime Comparison Measures\n\ntype: \"time_comparison\"\nbase_metric: Base measure name\ncomparison_type: yoy, mom, wow, dod, qoq, prior_period\ntime_offset: Custom offset (e.g., \"3 months\")\ncalculation: percent_change, difference, or ratio"
  },
  {
    "objectID": "python-api.html#join",
    "href": "python-api.html#join",
    "title": "Python API",
    "section": "Join",
    "text": "Join\nDefine a join relationship:\nfrom sidemantic import Relationship\n\n# belongs_to (foreign key in THIS table)\ncustomers_join = Join(\n    name=\"customers\",\n    type=\"many_to_one\",\n    foreign_key=\"customer_id\"\n)\n\n# has_many (foreign key in OTHER table)\norders_join = Join(\n    name=\"orders\",\n    type=\"one_to_many\",\n    foreign_key=\"customer_id\"\n)\n\n# has_one (foreign key in OTHER table, unique)\ninvoice_join = Join(\n    name=\"invoice\",\n    type=\"one_to_one\",\n    foreign_key=\"order_id\"\n)\n\nProperties\n\nname: Name of related model\ntype: belongs_to, has_many, or has_one\nforeign_key: Foreign key column name"
  },
  {
    "objectID": "python-api.html#parameter",
    "href": "python-api.html#parameter",
    "title": "Python API",
    "section": "Parameter",
    "text": "Parameter\nDefine query parameters:\nfrom sidemantic import Parameter\n\nstart_date = Parameter(\n    name=\"start_date\",\n    type=\"date\",\n    default_value=\"2024-01-01\"\n)\n\nmin_amount = Parameter(\n    name=\"min_amount\",\n    type=\"number\",\n    default_value=100\n)\n\nregion = Parameter(\n    name=\"region\",\n    type=\"string\",\n    default_value=\"US\",\n    allowed_values=[\"US\", \"EU\", \"APAC\"]\n)\n\nProperties\n\nname: Parameter name\ntype: string, number, date, unquoted, yesno\ndefault_value: Default value\nallowed_values: List of valid values\ndescription: Human-readable description"
  },
  {
    "objectID": "python-api.html#complete-example",
    "href": "python-api.html#complete-example",
    "title": "Python API",
    "section": "Complete Example",
    "text": "Complete Example\nfrom sidemantic import (\n    SemanticLayer, Model, Dimension, Metric, Relationship, Segment, Parameter\n)\n\n# Create semantic layer\nlayer = SemanticLayer()\n\n# Define orders model\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n\n    dimensions=[\n        Dimension(name=\"status\", type=\"categorical\", expr=\"status\"),\n        Dimension(name=\"order_date\", type=\"time\", expr=\"created_at\", granularity=\"day\"),\n        Dimension(name=\"country\", type=\"categorical\", expr=\"country\"),\n        Dimension(name=\"state\", type=\"categorical\", expr=\"state\", parent=\"country\"),\n        Dimension(name=\"city\", type=\"categorical\", expr=\"city\", parent=\"state\")\n    ],\n\n    metrics=[\n        Metric(name=\"revenue\", agg=\"sum\", expr=\"amount\", format=\"$#,##0.00\"),\n        Metric(name=\"order_count\", agg=\"count\"),\n        Metric(\n            name=\"completed_revenue\",\n            agg=\"sum\",\n            expr=\"amount\",\n            filters=[\"{model}.status = 'completed'\"]\n        ),\n        Metric(\n            name=\"conversion_rate\",\n            type=\"ratio\",\n            numerator=\"completed_orders\",\n            denominator=\"total_orders\"\n        )\n    ],\n\n    segments=[\n        Segment(name=\"completed\", sql=\"{model}.status = 'completed'\"),\n        Segment(name=\"high_value\", sql=\"{model}.amount &gt;= 500\")\n    ],\n\n    relationships=[\n        Relationship(name=\"customers\", type=\"many_to_one\", foreign_key=\"customer_id\")\n    ]\n)\n\n# Define customers model\ncustomers = Model(\n    name=\"customers\",\n    table=\"customers\",\n    primary_key=\"id\",\n\n    dimensions=[\n        Dimension(name=\"region\", type=\"categorical\", expr=\"region\")\n    ],\n\n    metrics=[\n        Metric(name=\"customer_count\", agg=\"count\")\n    ],\n\n    relationships=[\n        Relationship(name=\"orders\", type=\"one_to_many\", foreign_key=\"customer_id\")\n    ]\n)\n\n# Add models\nlayer.add_model(orders)\nlayer.add_model(customers)\n\n# Query with SQL\nresult = layer.sql(\"\"\"\n    SELECT orders.revenue, customers.region\n    FROM orders\n    WHERE orders.status = 'completed'\n\"\"\")\n\ndf = result.fetchdf()\nprint(df)\n\n# Or programmatically\nresult = layer.query(\n    metrics=[\"orders.revenue\", \"customers.customer_count\"],\n    dimensions=[\"customers.region\"],\n    segments=[\"orders.completed\"],\n    filters=[\"orders.order_date &gt;= 'last 30 days'\"]\n)\n\ndf = result.fetchdf()\nprint(df)\n\n# Use hierarchy drill-down\npath = orders.get_hierarchy_path(\"city\")  # ['country', 'state', 'city']\nnext_level = orders.get_drill_down(\"state\")  # 'city'\n\n# Ungrouped query for raw rows\nsql = layer.compile(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.order_id\", \"orders.customer_id\"],\n    ungrouped=True\n)"
  },
  {
    "objectID": "measures.html",
    "href": "measures.html",
    "title": "Measures",
    "section": "",
    "text": "Measures define how to aggregate and calculate metrics."
  },
  {
    "objectID": "measures.html#simple-aggregations",
    "href": "measures.html#simple-aggregations",
    "title": "Measures",
    "section": "Simple Aggregations",
    "text": "Simple Aggregations\nBasic aggregations on a single column:\nmeasures:\n  - name: revenue\n    agg: sum\n    expr: amount\n\n  - name: order_count\n    agg: count\n\n  - name: avg_price\n    agg: avg\n    expr: price\n\n  - name: max_amount\n    agg: max\n    expr: amount\nAvailable aggregations: sum, count, count_distinct, avg, min, max, median"
  },
  {
    "objectID": "measures.html#filtered-measures",
    "href": "measures.html#filtered-measures",
    "title": "Measures",
    "section": "Filtered Measures",
    "text": "Filtered Measures\nApply filters to specific measures:\nmeasures:\n  - name: completed_revenue\n    agg: sum\n    expr: amount\n    filters: [\"status = 'completed'\"]\n\n  - name: us_orders\n    agg: count\n    filters: [\"country = 'US'\", \"amount &gt; 0\"]\nFilters are ANDed together."
  },
  {
    "objectID": "measures.html#ratio-measures",
    "href": "measures.html#ratio-measures",
    "title": "Measures",
    "section": "Ratio Measures",
    "text": "Ratio Measures\nDivide one measure by another:\nmeasures:\n  - name: conversion_rate\n    type: ratio\n    numerator: completed_orders\n    denominator: total_orders\n\n  - name: profit_margin\n    type: ratio\n    numerator: profit\n    denominator: revenue\nResults in: numerator / NULLIF(denominator, 0)\n\nTime-Offset Ratios\nCompare to a previous period:\nmeasures:\n  - name: mom_growth\n    type: ratio\n    numerator: revenue\n    denominator: revenue\n    offset_window: \"1 month\"\nCalculates: current revenue / last month’s revenue"
  },
  {
    "objectID": "measures.html#derived-measures",
    "href": "measures.html#derived-measures",
    "title": "Measures",
    "section": "Derived Measures",
    "text": "Derived Measures\nFormula-based calculations:\nmeasures:\n  - name: profit\n    type: derived\n    expr: \"revenue - cost\"\n\n  - name: margin_pct\n    type: derived\n    expr: \"(revenue - cost) / revenue * 100\"\n\n  - name: items_per_order\n    type: derived\n    expr: \"total_items / order_count\"\nCan reference other measures by name."
  },
  {
    "objectID": "measures.html#cumulative-measures",
    "href": "measures.html#cumulative-measures",
    "title": "Measures",
    "section": "Cumulative Measures",
    "text": "Cumulative Measures\nRunning totals and period-to-date:\nmeasures:\n  # Rolling window\n  - name: last_7_days_revenue\n    type: cumulative\n    expr: revenue\n    window: \"7 days\"\n\n  # Month-to-date\n  - name: mtd_revenue\n    type: cumulative\n    expr: revenue\n    grain_to_date: month\n\n  # Year-to-date\n  - name: ytd_revenue\n    type: cumulative\n    expr: revenue\n    grain_to_date: year\nRequires a time dimension in the query."
  },
  {
    "objectID": "measures.html#time-comparison-measures",
    "href": "measures.html#time-comparison-measures",
    "title": "Measures",
    "section": "Time Comparison Measures",
    "text": "Time Comparison Measures\nYear-over-year, month-over-month changes:\nmeasures:\n  # Year-over-year growth\n  - name: yoy_revenue_growth\n    type: time_comparison\n    base_metric: revenue\n    comparison_type: yoy\n    calculation: percent_change\n\n  # Month-over-month\n  - name: mom_revenue\n    type: time_comparison\n    base_metric: revenue\n    comparison_type: mom\n    calculation: difference\n\n  # Custom offset\n  - name: vs_last_quarter\n    type: time_comparison\n    base_metric: revenue\n    time_offset: \"3 months\"\n    calculation: ratio\nCalculation types: - percent_change: (current - prior) / prior * 100 - difference: current - prior - ratio: current / prior"
  },
  {
    "objectID": "measures.html#conversion-metrics",
    "href": "measures.html#conversion-metrics",
    "title": "Measures",
    "section": "Conversion Metrics",
    "text": "Conversion Metrics\nTrack funnel conversions:\nmeasures:\n  - name: signup_to_purchase\n    type: conversion\n    entity: user_id\n    base_event: signup\n    conversion_event: purchase\n    conversion_window: \"7 days\"\nCalculates: users who did conversion_event within window after base_event / total users who did base_event"
  },
  {
    "objectID": "measures.html#measure-properties",
    "href": "measures.html#measure-properties",
    "title": "Measures",
    "section": "Measure Properties",
    "text": "Measure Properties\n\nAll Measures\n\nname: Unique identifier\ndescription: Human-readable description\nlabel: Display name (defaults to name)\n\n\n\nSimple Aggregations\n\nagg: Aggregation function (sum, count, avg, etc.)\nexpr: SQL expression to aggregate (defaults to * for count)\nfilters: WHERE conditions for this measure\n\n\n\nComplex Measures\n\ntype: Measure type (ratio, derived, cumulative, time_comparison, conversion)\nType-specific properties (see sections above)\n\n\n\nNull Handling\nmeasures:\n  - name: revenue\n    agg: sum\n    expr: amount\n    fill_nulls_with: 0  # Return 0 instead of NULL"
  },
  {
    "objectID": "measures.html#python-api",
    "href": "measures.html#python-api",
    "title": "Measures",
    "section": "Python API",
    "text": "Python API\nfrom sidemantic import Measure\n\n# Simple\nrevenue = Measure(name=\"revenue\", agg=\"sum\", expr=\"amount\")\n\n# Filtered\ncompleted = Measure(\n    name=\"completed_revenue\",\n    agg=\"sum\",\n    expr=\"amount\",\n    filters=[\"status = 'completed'\"]\n)\n\n# Ratio\nmargin = Measure(\n    name=\"margin\",\n    type=\"ratio\",\n    numerator=\"profit\",\n    denominator=\"revenue\"\n)\n\n# Derived\nprofit = Measure(\n    name=\"profit\",\n    type=\"derived\",\n    expr=\"revenue - cost\"\n)\n\n# Cumulative\nrunning_total = Measure(\n    name=\"running_total\",\n    type=\"cumulative\",\n    expr=\"revenue\",\n    window=\"7 days\"\n)"
  },
  {
    "objectID": "measures.html#best-practices",
    "href": "measures.html#best-practices",
    "title": "Measures",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipStart Simple\n\n\n\nDefine basic aggregations first, then build complex measures on top: 1. Base measures (revenue, count) 2. Filtered measures (completed_revenue) 3. Ratios (conversion_rate = completed / total) 4. Derived (margin = profit / revenue)\n\n\n\n\n\n\n\n\nWarningSQL Expressions\n\n\n\nMeasures support full SQL in the expr field:\n- name: total_value\n  agg: sum\n  expr: \"quantity * price * (1 - discount_pct)\"\n\n\n\n\n\n\n\n\nTipReusability\n\n\n\nDefine measures once, use everywhere: - In SQL queries: SELECT revenue FROM orders - In Python: layer.query(metrics=[\"orders.revenue\"]) - In other measures: expr: \"revenue - cost\""
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Examples",
    "section": "",
    "text": "YAMLPython\n\n\nmodels:\n  - name: orders\n    table: orders\n    primary_key: id\n    metrics:\n      - name: revenue\n        agg: sum\n        expr: amount\n\n\nfrom sidemantic import SemanticLayer, Model, Metric\n\nlayer = SemanticLayer()\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n    metrics=[\n        Metric(name=\"revenue\", agg=\"sum\", expr=\"amount\")\n    ]\n)\n\nlayer.add_model(orders)\n\n\n\nQuery with SQL:\nlayer.sql(\"SELECT revenue FROM orders\")\nOr with native Python API:\n# Get SQL only\nsql = layer.compile(metrics=[\"orders.revenue\"])\n\n# Execute and get results\nresult = layer.query(metrics=[\"orders.revenue\"])\ndf = result.fetchdf()"
  },
  {
    "objectID": "examples.html#basic-query",
    "href": "examples.html#basic-query",
    "title": "Examples",
    "section": "",
    "text": "YAMLPython\n\n\nmodels:\n  - name: orders\n    table: orders\n    primary_key: id\n    metrics:\n      - name: revenue\n        agg: sum\n        expr: amount\n\n\nfrom sidemantic import SemanticLayer, Model, Metric\n\nlayer = SemanticLayer()\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n    metrics=[\n        Metric(name=\"revenue\", agg=\"sum\", expr=\"amount\")\n    ]\n)\n\nlayer.add_model(orders)\n\n\n\nQuery with SQL:\nlayer.sql(\"SELECT revenue FROM orders\")\nOr with native Python API:\n# Get SQL only\nsql = layer.compile(metrics=[\"orders.revenue\"])\n\n# Execute and get results\nresult = layer.query(metrics=[\"orders.revenue\"])\ndf = result.fetchdf()"
  },
  {
    "objectID": "examples.html#filtering-and-grouping",
    "href": "examples.html#filtering-and-grouping",
    "title": "Examples",
    "section": "Filtering and Grouping",
    "text": "Filtering and Grouping\nlayer.sql(\"\"\"\n    SELECT revenue, status\n    FROM orders\n    WHERE status IN ('completed', 'shipped')\n\"\"\")\n\n\n\n\n\n\nTipNo GROUP BY Needed\n\n\n\nThe semantic layer automatically groups by dimensions. Just select what you want!"
  },
  {
    "objectID": "examples.html#time-dimensions",
    "href": "examples.html#time-dimensions",
    "title": "Examples",
    "section": "Time Dimensions",
    "text": "Time Dimensions\n\nYAMLPython\n\n\ndimensions:\n  - name: order_date\n    type: time\n    expr: order_date\n    granularity: day\n\n\nfrom sidemantic import Dimension\n\nDimension(\n    name=\"order_date\",\n    type=\"time\",\n    expr=\"order_date\",\n    granularity=\"day\"\n)\n\n\n\n# Automatic time grouping\nlayer.sql(\"\"\"\n    SELECT revenue, order_date\n    FROM orders\n\"\"\")"
  },
  {
    "objectID": "examples.html#cross-model-queries",
    "href": "examples.html#cross-model-queries",
    "title": "Examples",
    "section": "Cross-Model Queries",
    "text": "Cross-Model Queries\n\nYAMLPython\n\n\nmodels:\n  - name: orders\n    table: orders\n    primary_key: id\n    relationships:\n      - name: customers\n        type: many_to_one\n        foreign_key: customer_id\n\n  - name: customers\n    table: customers\n    primary_key: id\n    dimensions:\n      - name: region\n        type: categorical\n        expr: region\n\n\nfrom sidemantic import Model, Relationship, Dimension\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n    relationships=[\n        Relationship(name=\"customers\", type=\"many_to_one\", foreign_key=\"customer_id\")\n    ]\n)\n\ncustomers = Model(\n    name=\"customers\",\n    table=\"customers\",\n    primary_key=\"id\",\n    dimensions=[\n        Dimension(name=\"region\", type=\"categorical\", expr=\"region\")\n    ]\n)\n\n\n\n# Automatic join\nlayer.sql(\"\"\"\n    SELECT orders.revenue, customers.region\n    FROM orders\n\"\"\")"
  },
  {
    "objectID": "examples.html#ratio-measures",
    "href": "examples.html#ratio-measures",
    "title": "Examples",
    "section": "Ratio Measures",
    "text": "Ratio Measures\nmeasures:\n  - name: completed_revenue\n    agg: sum\n    expr: amount\n    filters: [\"status = 'completed'\"]\n\n  - name: total_revenue\n    agg: sum\n    expr: amount\n\n  - name: completion_rate\n    type: ratio\n    numerator: completed_revenue\n    denominator: total_revenue\nlayer.sql(\"SELECT completion_rate FROM orders\")"
  },
  {
    "objectID": "examples.html#derived-measures",
    "href": "examples.html#derived-measures",
    "title": "Examples",
    "section": "Derived Measures",
    "text": "Derived Measures\nmeasures:\n  - name: revenue\n    agg: sum\n    expr: amount\n\n  - name: cost\n    agg: sum\n    expr: cost\n\n  - name: profit\n    type: derived\n    expr: \"revenue - cost\"\n\n  - name: margin\n    type: derived\n    expr: \"profit / revenue\"\nlayer.sql(\"SELECT revenue, profit, margin FROM orders\")"
  },
  {
    "objectID": "examples.html#cumulative-metrics",
    "href": "examples.html#cumulative-metrics",
    "title": "Examples",
    "section": "Cumulative Metrics",
    "text": "Cumulative Metrics\n\nYAMLPython\n\n\nmetrics:\n  - name: daily_revenue\n    agg: sum\n    expr: amount\n\n  - name: running_total\n    type: cumulative\n    expr: daily_revenue\n    window: \"7 days\"\n\n  - name: mtd_revenue\n    type: cumulative\n    expr: daily_revenue\n    grain_to_date: month\n\n\nMetric(name=\"daily_revenue\", agg=\"sum\", expr=\"amount\"),\nMetric(name=\"running_total\", type=\"cumulative\",\n       expr=\"daily_revenue\", window=\"7 days\"),\nMetric(name=\"mtd_revenue\", type=\"cumulative\",\n       expr=\"daily_revenue\", grain_to_date=\"month\")\n\n\n\nlayer.sql(\"\"\"\n    SELECT order_date, running_total, mtd_revenue\n    FROM orders\n\"\"\")"
  },
  {
    "objectID": "examples.html#parameterized-queries",
    "href": "examples.html#parameterized-queries",
    "title": "Examples",
    "section": "Parameterized Queries",
    "text": "Parameterized Queries\n\nYAMLPython\n\n\nparameters:\n  - name: start_date\n    type: date\n    default_value: \"2024-01-01\"\n\n  - name: min_amount\n    type: number\n    default_value: 100\n\n\nfrom sidemantic import Parameter\n\nParameter(name=\"start_date\", type=\"date\", default_value=\"2024-01-01\"),\nParameter(name=\"min_amount\", type=\"number\", default_value=100)\n\n\n\nlayer.sql(\n    \"SELECT revenue FROM orders WHERE order_date &gt;= {{ start_date }}\",\n    parameters={\"start_date\": \"2024-06-01\"}\n)\n\n\n\n\n\n\nWarningParameter Syntax\n\n\n\nDON’T add quotes around { param } - they’re added automatically based on type: - ❌ WHERE date &gt;= '{{ start_date }}' (double quotes!) - ✅ WHERE date &gt;= {{ start_date }}"
  },
  {
    "objectID": "examples.html#multi-hop-joins",
    "href": "examples.html#multi-hop-joins",
    "title": "Examples",
    "section": "Multi-Hop Joins",
    "text": "Multi-Hop Joins\n\nYAMLPython\n\n\nmodels:\n  - name: orders\n    relationships:\n      - name: customers\n        type: many_to_one\n        foreign_key: customer_id\n\n  - name: customers\n    relationships:\n      - name: regions\n        type: many_to_one\n        foreign_key: region_id\n\n  - name: regions\n    dimensions:\n      - name: country\n        type: categorical\n        expr: country\n\n\norders = Model(\n    name=\"orders\",\n    relationships=[\n        Relationship(name=\"customers\", type=\"many_to_one\", foreign_key=\"customer_id\")\n    ]\n)\n\ncustomers = Model(\n    name=\"customers\",\n    relationships=[\n        Relationship(name=\"regions\", type=\"many_to_one\", foreign_key=\"region_id\")\n    ]\n)\n\nregions = Model(\n    name=\"regions\",\n    dimensions=[\n        Dimension(name=\"country\", type=\"categorical\", expr=\"country\")\n    ]\n)\n\n\n\n# Spans 2 hops: orders -&gt; customers -&gt; regions\nlayer.sql(\"\"\"\n    SELECT orders.revenue, regions.country\n    FROM orders\n\"\"\")"
  },
  {
    "objectID": "examples.html#real-examples",
    "href": "examples.html#real-examples",
    "title": "Examples",
    "section": "Real Examples",
    "text": "Real Examples\nSee /examples directory for:\n\nsql_query_example.py - SQL interface examples\nparameters_example.py - Parameterized queries\nsymmetric_aggregates_example.py - Fan-out handling\nstreamlit_dashboard.py - Interactive dashboard"
  },
  {
    "objectID": "marimo-demo.html",
    "href": "marimo-demo.html",
    "title": "Interactive Notebook (marimo)",
    "section": "",
    "text": "This page embeds a live marimo app. Change the controls to re-run queries against a DuckDB-backed demo of the Sidemantic semantic layer.\n\n    \n    \n    \n    import%20marimo%20as%20mo%0Aimport%20duckdb%0Afrom%20sidemantic%20import%20Model%2C%20Dimension%2C%20Measure%2C%20Join%0A%0A%23%20In-memory%20DuckDB%20to%20avoid%20file%20locking%20during%20builds%0Aconn%20%3D%20duckdb.connect(%22%3Amemory%3A%22)\n\n\n    \n    \n    \n    %23%20Minimal%20semantic%20layer%20wrapper%20using%20Sidemantic%20internals%0Afrom%20sidemantic.core.semantic_graph%20import%20SemanticGraph%0Afrom%20sidemantic.sql.generator_v2%20import%20SQLGenerator%0Afrom%20sidemantic.validation%20import%20(%0A%20%20%20%20ModelValidationError%2C%0A%20%20%20%20QueryValidationError%2C%0A%20%20%20%20validate_model%2C%0A%20%20%20%20validate_query%2C%0A)%0A%0Aclass%20_SemanticLayerWrapper%3A%0A%20%20%20%20def%20__init__(self%2C%20conn)%3A%0A%20%20%20%20%20%20%20%20self.conn%20%3D%20conn%0A%20%20%20%20%20%20%20%20self.graph%20%3D%20SemanticGraph()%0A%20%20%20%20%20%20%20%20self.dialect%20%3D%20%22duckdb%22%0A%0A%20%20%20%20def%20add_model(self%2C%20model)%3A%0A%20%20%20%20%20%20%20%20errors%20%3D%20validate_model(model)%0A%20%20%20%20%20%20%20%20if%20errors%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20raise%20ModelValidationError(%22Model%20validation%20failed%3A%5Cn%22%20%2B%20%22%5Cn%22.join(f%22%20%20-%20%7Be%7D%22%20for%20e%20in%20errors))%0A%20%20%20%20%20%20%20%20self.graph.add_model(model)%0A%0A%20%20%20%20def%20list_models(self)%3A%0A%20%20%20%20%20%20%20%20return%20list(self.graph.models.keys())%0A%0A%20%20%20%20def%20compile(self%2C%20*%2C%20metrics%3DNone%2C%20dimensions%3DNone%2C%20filters%3DNone%2C%20order_by%3DNone%2C%20limit%3DNone%2C%20offset%3DNone%2C%20dialect%3DNone)%3A%0A%20%20%20%20%20%20%20%20metrics%20%3D%20metrics%20or%20%5B%5D%0A%20%20%20%20%20%20%20%20dimensions%20%3D%20dimensions%20or%20%5B%5D%0A%20%20%20%20%20%20%20%20errors%20%3D%20validate_query(metrics%2C%20dimensions%2C%20self.graph)%0A%20%20%20%20%20%20%20%20if%20errors%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20raise%20QueryValidationError(%22Query%20validation%20failed%3A%5Cn%22%20%2B%20%22%5Cn%22.join(f%22%20%20-%20%7Be%7D%22%20for%20e%20in%20errors))%0A%20%20%20%20%20%20%20%20sql%20%3D%20SQLGenerator(self.graph%2C%20dialect%3Ddialect%20or%20self.dialect).generate(%0A%20%20%20%20%20%20%20%20%20%20%20%20metrics%3Dmetrics%2C%20dimensions%3Ddimensions%2C%20filters%3Dfilters%2C%20order_by%3Dorder_by%2C%20limit%3Dlimit%2C%20offset%3Doffset%0A%20%20%20%20%20%20%20%20)%0A%20%20%20%20%20%20%20%20return%20sql%0A%0A%20%20%20%20def%20query(self%2C%20*%2C%20metrics%3DNone%2C%20dimensions%3DNone%2C%20filters%3DNone%2C%20order_by%3DNone%2C%20limit%3DNone)%3A%0A%20%20%20%20%20%20%20%20sql%20%3D%20self.compile(metrics%3Dmetrics%2C%20dimensions%3Ddimensions%2C%20filters%3Dfilters%2C%20order_by%3Dorder_by%2C%20limit%3Dlimit)%0A%20%20%20%20%20%20%20%20return%20self.conn.execute(sql)%0A%0A%20%20%20%20def%20sql(self%2C%20query%3A%20str)%3A%0A%20%20%20%20%20%20%20%20from%20sidemantic.sql.query_rewriter%20import%20QueryRewriter%0A%20%20%20%20%20%20%20%20rewriter%20%3D%20QueryRewriter(self.graph%2C%20dialect%3Dself.dialect)%0A%20%20%20%20%20%20%20%20return%20self.conn.execute(rewriter.rewrite(query))%0A%0Alayer%20%3D%20_SemanticLayerWrapper(conn)\n\n\n    \n    \n    \n    %23%20Seed%20demo%20tables%20if%20empty%0Aconn.execute(%0A%20%20%20%20%22%22%22%0A%20%20%20%20CREATE%20TABLE%20IF%20NOT%20EXISTS%20orders%20(%0A%20%20%20%20%20%20%20%20id%20INTEGER%2C%0A%20%20%20%20%20%20%20%20customer_id%20INTEGER%2C%0A%20%20%20%20%20%20%20%20status%20VARCHAR%2C%0A%20%20%20%20%20%20%20%20order_date%20DATE%2C%0A%20%20%20%20%20%20%20%20amount%20DECIMAL(10%2C%202)%0A%20%20%20%20)%0A%20%20%20%20%22%22%22%0A)%0Aif%20conn.execute(%22SELECT%20COUNT(*)%20FROM%20orders%22).fetchone()%5B0%5D%20%3D%3D%200%3A%0A%20%20%20%20conn.execute(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20INSERT%20INTO%20orders%20VALUES%0A%20%20%20%20%20%20%20%20%20%20%20%20(1%2C%201%2C%20'completed'%2C%20'2024-01-15'%2C%20250.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(2%2C%201%2C%20'completed'%2C%20'2024-02-10'%2C%20180.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(3%2C%202%2C%20'pending'%2C%20'2024-02-15'%2C%20320.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(4%2C%202%2C%20'completed'%2C%20'2024-03-01'%2C%20410.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(5%2C%203%2C%20'completed'%2C%20'2024-03-10'%2C%20190.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(6%2C%203%2C%20'cancelled'%2C%20'2024-03-15'%2C%2075.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(7%2C%201%2C%20'completed'%2C%20'2024-04-01'%2C%20290.00)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(8%2C%202%2C%20'completed'%2C%20'2024-04-15'%2C%20350.00)%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%0Aconn.execute(%0A%20%20%20%20%22%22%22%0A%20%20%20%20CREATE%20TABLE%20IF%20NOT%20EXISTS%20customers%20(%0A%20%20%20%20%20%20%20%20id%20INTEGER%2C%0A%20%20%20%20%20%20%20%20name%20VARCHAR%2C%0A%20%20%20%20%20%20%20%20region%20VARCHAR%2C%0A%20%20%20%20%20%20%20%20tier%20VARCHAR%0A%20%20%20%20)%0A%20%20%20%20%22%22%22%0A)%0Aif%20conn.execute(%22SELECT%20COUNT(*)%20FROM%20customers%22).fetchone()%5B0%5D%20%3D%3D%200%3A%0A%20%20%20%20conn.execute(%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20%20%20%20%20INSERT%20INTO%20customers%20VALUES%0A%20%20%20%20%20%20%20%20%20%20%20%20(1%2C%20'Alice'%2C%20'US'%2C%20'premium')%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(2%2C%20'Bob'%2C%20'EU'%2C%20'standard')%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20(3%2C%20'Charlie'%2C%20'US'%2C%20'premium')%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20)\n\n\n    \n    \n    \n    %23%20Register%20models%0Aorders%20%3D%20Model(%0A%20%20%20%20name%3D%22orders%22%2C%0A%20%20%20%20table%3D%22orders%22%2C%0A%20%20%20%20primary_key%3D%22id%22%2C%0A%20%20%20%20dimensions%3D%5B%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22status%22%2C%20type%3D%22categorical%22%2C%20sql%3D%22status%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22order_date%22%2C%20type%3D%22time%22%2C%20sql%3D%22order_date%22%2C%20granularity%3D%22day%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20measures%3D%5B%0A%20%20%20%20%20%20%20%20Measure(name%3D%22revenue%22%2C%20agg%3D%22sum%22%2C%20expr%3D%22amount%22)%2C%0A%20%20%20%20%20%20%20%20Measure(name%3D%22order_count%22%2C%20agg%3D%22count%22)%2C%0A%20%20%20%20%20%20%20%20Measure(name%3D%22avg_order_value%22%2C%20agg%3D%22avg%22%2C%20expr%3D%22amount%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20joins%3D%5BJoin(name%3D%22customers%22%2C%20type%3D%22belongs_to%22%2C%20foreign_key%3D%22customer_id%22)%5D%2C%0A)%0A%0Acustomers%20%3D%20Model(%0A%20%20%20%20name%3D%22customers%22%2C%0A%20%20%20%20table%3D%22customers%22%2C%0A%20%20%20%20primary_key%3D%22id%22%2C%0A%20%20%20%20dimensions%3D%5B%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22region%22%2C%20type%3D%22categorical%22%2C%20sql%3D%22region%22)%2C%0A%20%20%20%20%20%20%20%20Dimension(name%3D%22tier%22%2C%20type%3D%22categorical%22%2C%20sql%3D%22tier%22)%2C%0A%20%20%20%20%5D%2C%0A%20%20%20%20measures%3D%5BMeasure(name%3D%22customer_count%22%2C%20agg%3D%22count%22)%5D%2C%0A)%0A%0Alayer.add_model(orders)%0Alayer.add_model(customers)\n\n\n    \n    Sidemantic Interactive Demo\n    \n    %23%20Title%0Amo.md(%22%23%20Sidemantic%20Interactive%20Demo%22)\n\n\n    \n    \n    \n    %23%20Controls%0Astatus_select%20%3D%20mo.ui.dropdown(options%3D%5B%22all%22%2C%20%22completed%22%2C%20%22pending%22%2C%20%22cancelled%22%5D%2C%20value%3D%22all%22%2C%20label%3D%22Order%20Status%22)%0Aregion_select%20%3D%20mo.ui.dropdown(options%3D%5B%22all%22%2C%20%22US%22%2C%20%22EU%22%5D%2C%20value%3D%22all%22%2C%20label%3D%22Region%22)%0Amo.hstack(%5Bstatus_select%2C%20region_select%5D)\n\n\n    \n    Active Filters: None\n    \n    %23%20Build%20filters%20from%20controls%0Afilters%20%3D%20%5B%5D%0Aif%20status_select.value%20!%3D%20%22all%22%3A%0A%20%20%20%20filters.append(f%22orders.status%20%3D%20'%7Bstatus_select.value%7D'%22)%0Aif%20region_select.value%20!%3D%20%22all%22%3A%0A%20%20%20%20filters.append(f%22customers.region%20%3D%20'%7Bregion_select.value%7D'%22)%0Amo.md(f%22**Active%20Filters%3A**%20%7B'%2C%20'.join(filters)%20if%20filters%20else%20'None'%7D%22)\n\n\n            \n            Key Metrics\nTotal Revenue: $2,065.00\nOrder Count: 8\nAvg Order Value: $258.12\n            \n            %23%20Key%20metrics%20panel%0Adimensions%20%3D%20%5B%22customers.region%22%5D%20if%20region_select.value%20!%3D%20%22all%22%20else%20%5B%5D%0Adf%20%3D%20layer.query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%2C%20%22orders.order_count%22%2C%20%22orders.avg_order_value%22%5D%2C%0A%20%20%20%20dimensions%3Ddimensions%2C%0A%20%20%20%20filters%3Dfilters%2C%0A).fetchdf()%0A%0Amo.md(%0A%20%20%20%20f%22%22%22%0A%23%23%20Key%20Metrics%0A%0A**Total%20Revenue%3A**%20%24%7Bdf%5B'revenue'%5D.sum()%3A%2C.2f%7D%0A%0A**Order%20Count%3A**%20%7Bint(df%5B'order_count'%5D.sum())%7D%0A%0A**Avg%20Order%20Value%3A**%20%24%7Bdf%5B'avg_order_value'%5D.mean()%3A%2C.2f%7D%0A%22%22%22%0A)\n        \n\n    \n    \n    \n    %23%20Revenue%20by%20status%20table%0Astatus_df%20%3D%20layer.query(%0A%20%20%20%20metrics%3D%5B%22orders.revenue%22%2C%20%22orders.order_count%22%5D%2C%0A%20%20%20%20dimensions%3D%5B%22orders.status%22%5D%2C%0A%20%20%20%20filters%3Dfilters%2C%0A).fetchdf()%0Amo.ui.table(status_df)\n\n\n“““)\n\n```python {.marimo}\n#| echo: false\nmo.md(\"\"\"\n## Try Your Own Query\n\nWrite SQL directly against the semantic layer:\n\"\"\")\nquery_input = mo.ui.text_area(value=\"SELECT revenue, status FROM orders WHERE status = 'completed'\", label=\"SQL Query\")\nquery_input\n\n    \n    \n    \n    %23%20Execute%20custom%20SQL%0Atry%3A%0A%20%20%20%20custom_df%20%3D%20layer.sql(query_input.value).fetchdf()%0A%20%20%20%20mo.ui.table(custom_df)%0Aexcept%20Exception%20as%20e%3A%0A%20%20%20%20mo.md(f%22**Error%3A**%20%7Be%7D%22)\n\n\n            \n            Notes\n\nSelecting a region adds a semantic join orders → customers.\nMetrics remain consistent regardless of filters and joins.\nThe SQL shown is compiled by the semantic layer.\n\n            \n            mo.md(%22%22%22%0A%23%23%20Notes%0A%0A-%20Selecting%20a%20region%20adds%20a%20semantic%20join%20orders%20%E2%86%92%20customers.%0A-%20Metrics%20remain%20consistent%20regardless%20of%20filters%20and%20joins.%0A-%20The%20SQL%20shown%20is%20compiled%20by%20the%20semantic%20layer.%0A%22%22%22)"
  },
  {
    "objectID": "STATUS.html",
    "href": "STATUS.html",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "✅ Model, Dimension, Metric abstractions with Pydantic\n✅ Relationship-based automatic joins (many_to_one, one_to_many, one_to_one)\n✅ SemanticGraph with BFS-based join path discovery\n✅ Python-first API with SemanticLayer class\n✅ Automatic dependency detection for derived metrics\n\n\n\n\n\n✅ SQLGlot builder API-based SQL generation\n✅ CTE-based query structure\n✅ Time dimension granularity support (hour, day, week, month, quarter, year)\n✅ Metric aggregation (sum, count, count_distinct, avg, min, max, median)\n✅ Ratio and derived metrics with auto-detected dependencies\n✅ Filter support with table prefix handling\n✅ Multi-model queries with automatic joins\n✅ Recursive metric dependency resolution\n\n\n\n\n\n✅ Base adapter interface with parse/export methods\n✅ Sidemantic native YAML adapter (import/export)\n✅ Cube adapter (import/export)\n✅ MetricFlow adapter (import/export) with all 5 metric types\n✅ LookML adapter (placeholder - requires full grammar parser)\n\n\n\n\n\n✅ .query() method for execution\n✅ .compile() method for SQL generation\n✅ .sql() method for SQL query rewriting\n✅ DuckDB integration\n✅ Dialect transpilation support\n\n\n\n\n\n✅ uv-based Python package management\n✅ Proper package structure\n✅ Pydantic models for type safety\n✅ Comprehensive examples and tests\n\n\n\n\n\n\n\n\nSimple primary keys: Use primary_key directly on models\nExplicit relationships: Clear types (many_to_one, one_to_many, one_to_one)\nConsistent field names: sql everywhere for expressions\nUnified terminology: metrics consistently\nAuto-detected dependencies: No manual dependency lists needed\n\nExample:\nmodels:\n  - name: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\nmetrics:\n  # Dependencies auto-detected!\n  - name: total_revenue\n    sql: orders.revenue\n\n\n\n\nExample Output:\nWITH orders_cte AS (\n  SELECT\n    order_id AS order_id,\n    customer_id AS customer_id,\n    status AS status,\n    order_amount AS revenue_raw\n  FROM public.orders\n)\nSELECT\n  orders_cte.status AS status,\n  SUM(orders_cte.revenue_raw) AS revenue\nFROM orders_cte\nGROUP BY 1\n\n\n\n\n\n\n✅ Cross-model metrics: Metrics can reference metrics from multiple models via recursive dependency resolution\n✅ Multi-hop joins: BFS join path discovery supports 2+ hop joins with intermediate model inclusion\n✅ Derived metrics: Formula parsing with automatic dependency detection\n✅ Cumulative metrics: Running totals and rolling windows with window functions (tested with real data)\n✅ Conversion funnel metrics: Self-join pattern for event-based conversion tracking (tested with real data)\n✅ Time comparison metrics: YoY, MoM, WoW, DoD, QoQ with percent_change, difference, and ratio calculations using LAG window functions\n✅ Segments: Reusable named filters with {model} placeholder templating\n✅ Metric-level filters: Automatically applied filters for consistent business logic\n✅ Jinja2 templating: Full conditional logic, loops, and filters in SQL fields\n✅ Model inheritance: extends field for inheriting dimensions, metrics, relationships, segments\n✅ Metric inheritance: Extend base metrics with additional filters or overrides\n✅ Hierarchies: Parent/child dimension relationships for drill-down navigation\n✅ Drill-down API: get_hierarchy_path(), get_drill_down(), get_drill_up() helpers\n✅ Relative date ranges: Natural language parsing (“last 7 days”, “this month”, etc.)\n✅ Ungrouped queries: Raw row access without aggregation for detail views\n✅ Native YAML format: Complete Sidemantic YAML schema with import/export (see docs/YAML_FORMAT.md)\n✅ Export adapters: Full round-trip support for Sidemantic ↔︎ Cube ↔︎ MetricFlow\n\n\n\n\n\n✅ Display formatting: format and value_format_name on metrics and dimensions\n✅ Drill fields: Define drill-down paths for BI tool integration\n✅ Non-additivity markers: non_additive_dimension to prevent incorrect aggregation\n✅ Default dimensions: default_time_dimension and default_grain for metrics\n✅ Comprehensive metadata: Labels, descriptions on all objects\n\n\n\n\n\n✅ 202 passing tests across all features with comprehensive coverage\n✅ Real DuckDB integration tests\n✅ Round-trip adapter tests (Sidemantic → Cube/MetricFlow → Sidemantic)\n✅ Multi-hop join verification\n✅ Automatic dependency detection tests\n✅ Jinja template integration tests\n✅ Inheritance resolution tests\n✅ Hierarchy navigation tests\n✅ Relative date parsing tests\n✅ Ungrouped query tests\n✅ Segment and metric-level filter tests\n\n\n\n\n\n\nQuery optimization: Add query plan optimization and pushdown strategies\nPre-aggregations: Implement caching layer similar to Cube’s rollups\nLookML adapter: Requires full grammar parser for complete import support\n\n\n\n\nsidemantic/\n├── sidemantic/\n│   ├── core/\n│   │   ├── dimension.py         ✅ Dimension types with granularity\n│   │   ├── metric.py            ✅ Metric types (ratio, derived, cumulative)\n│   │   ├── model.py             ✅ Model (dataset) definitions\n│   │   ├── relationship.py      ✅ Relationship definitions\n│   │   ├── dependency_analyzer.py ✅ Auto-detect metric dependencies\n│   │   ├── semantic_graph.py    ✅ Graph with join path discovery\n│   │   └── semantic_layer.py    ✅ Main API\n│   ├── sql/\n│   │   ├── generator_v2.py      ✅ SQLGlot builder-based SQL generation\n│   │   └── generator.py         ✅ Legacy SQLGlot AST generator\n│   ├── adapters/\n│   │   ├── base.py              ✅ Base adapter interface\n│   │   ├── sidemantic.py        ✅ Native YAML (import/export)\n│   │   ├── cube.py              ✅ Cube YAML (import/export)\n│   │   ├── metricflow.py        ✅ MetricFlow YAML (import/export)\n│   │   └── lookml.py            ⚠️  LookML (placeholder)\n│   ├── filters/                 📁 Empty (for future filter parsing)\n│   └── api/                     📁 Empty (for future REST API)\n├── tests/\n│   ├── test_basic.py            ✅ Core functionality tests\n│   ├── test_adapters.py         ✅ Adapter import tests\n│   ├── test_sidemantic_adapter.py ✅ Native YAML adapter tests\n│   ├── test_export_adapters.py  ✅ Export and round-trip tests\n│   ├── test_with_data.py        ✅ End-to-end with real DuckDB\n│   ├── test_derived_metrics.py  ✅ Formula parsing tests\n│   ├── test_multi_hop_joins.py  ✅ Multi-hop join tests\n│   ├── test_dependencies.py     ✅ Dependency detection tests\n│   ├── test_validation.py       ✅ Validation tests\n│   └── test_cumulative_metrics.py ⚠️  Window functions (partial)\n├── examples/\n│   ├── basic_example.py         ✅ Usage examples\n│   ├── export_example.py        ✅ Export demonstration\n│   ├── cube/                    📁 Cube YAML examples\n│   ├── metricflow/              📁 MetricFlow YAML examples\n│   └── sidemantic/              📁 Native YAML examples\n└── docs/\n    ├── STATUS.md                📄 This file\n    └── YAML_FORMAT.md           📄 Native YAML format specification\n\n\n\n\n\nExplicit relationship types (many_to_one, one_to_many, one_to_one) make join semantics clear and prevent ambiguity. No more guessing whether belongs_to means the FK is here or there!\n\n\n\nManual dependency lists are error-prone and redundant. SQL parsing automatically detects what metrics depend on, reducing boilerplate by ~50%.\n\n\n\n\nDialect-agnostic SQL generation\nParse, transform, and transpile SQL across databases\nEnables Snowflake/BigQuery/Postgres compatibility from single codebase\n\n\n\n\n\nMore readable than nested subqueries\nEasier to debug generated SQL\nBetter query optimizer hints on modern databases\n\n\n\n\n\nType safety for semantic model definitions\nValidation out of the box\nJSON/YAML serialization support\nGood IDE autocomplete\n\n\n\n\n\nShort-term (to make more useful): 1. Complete cumulative metrics with window functions 2. Add more example YAML files and documentation 3. Performance optimization for large models\nLong-term (to make production-ready): 1. Query caching and optimization 2. REST/GraphQL API layer 3. Pre-aggregation support (like Cube’s rollups) 4. dbt integration 5. Data governance and access control\n\n\n\nThe implementation incorporates best practices from:\n\nCube: Pre-aggregations, API-first design, multi-tenancy\nMetricFlow: Semantic graph, metric types\nLookML: Explores/views separation, dimension groups, drill-down\nHex: Multi-format import, interoperability focus\n\nKey insight: All semantic layers share core abstractions (models, dimensions, metrics, relationships) but differ in query optimization, caching, and consumption patterns."
  },
  {
    "objectID": "STATUS.html#completed",
    "href": "STATUS.html#completed",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "✅ Model, Dimension, Metric abstractions with Pydantic\n✅ Relationship-based automatic joins (many_to_one, one_to_many, one_to_one)\n✅ SemanticGraph with BFS-based join path discovery\n✅ Python-first API with SemanticLayer class\n✅ Automatic dependency detection for derived metrics\n\n\n\n\n\n✅ SQLGlot builder API-based SQL generation\n✅ CTE-based query structure\n✅ Time dimension granularity support (hour, day, week, month, quarter, year)\n✅ Metric aggregation (sum, count, count_distinct, avg, min, max, median)\n✅ Ratio and derived metrics with auto-detected dependencies\n✅ Filter support with table prefix handling\n✅ Multi-model queries with automatic joins\n✅ Recursive metric dependency resolution\n\n\n\n\n\n✅ Base adapter interface with parse/export methods\n✅ Sidemantic native YAML adapter (import/export)\n✅ Cube adapter (import/export)\n✅ MetricFlow adapter (import/export) with all 5 metric types\n✅ LookML adapter (placeholder - requires full grammar parser)\n\n\n\n\n\n✅ .query() method for execution\n✅ .compile() method for SQL generation\n✅ .sql() method for SQL query rewriting\n✅ DuckDB integration\n✅ Dialect transpilation support\n\n\n\n\n\n✅ uv-based Python package management\n✅ Proper package structure\n✅ Pydantic models for type safety\n✅ Comprehensive examples and tests"
  },
  {
    "objectID": "STATUS.html#recently-fixed",
    "href": "STATUS.html#recently-fixed",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "The SQL generator had an issue with SQLGlot AST construction. RESOLVED by refactoring to use SQLGlot’s builder API. Now generates complete queries with CTEs, SELECT, FROM, JOIN, WHERE, GROUP BY, ORDER BY, and LIMIT clauses.\nExample Output:\nWITH orders_cte AS (\n  SELECT\n    order_id AS order,\n    customer_id AS customer,\n    status AS status,\n    order_amount AS revenue_raw\n  FROM public.orders\n)\nSELECT\n  orders_cte.status AS status,\n  SUM(orders_cte.revenue_raw) AS revenue\nFROM orders_cte\nGROUP BY 1"
  },
  {
    "objectID": "STATUS.html#recently-completed",
    "href": "STATUS.html#recently-completed",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "✅ Cross-model metrics: Metrics can reference metrics from multiple models via recursive dependency resolution\n✅ Multi-hop joins: BFS join path discovery supports 2+ hop joins with intermediate model inclusion\n✅ Derived metrics: Formula parsing with automatic dependency detection\n✅ Cumulative metrics: Running totals and rolling windows with window functions (tested with real data)\n✅ Conversion funnel metrics: Self-join pattern for event-based conversion tracking (tested with real data)\n✅ Time comparison metrics: YoY, MoM, WoW, DoD, QoQ with percent_change, difference, and ratio calculations using LAG window functions\n✅ Segments: Reusable named filters with {model} placeholder templating\n✅ Metric-level filters: Automatically applied filters for consistent business logic\n✅ Jinja2 templating: Full conditional logic, loops, and filters in SQL fields\n✅ Model inheritance: extends field for inheriting dimensions, metrics, relationships, segments\n✅ Metric inheritance: Extend base metrics with additional filters or overrides\n✅ Hierarchies: Parent/child dimension relationships for drill-down navigation\n✅ Drill-down API: get_hierarchy_path(), get_drill_down(), get_drill_up() helpers\n✅ Relative date ranges: Natural language parsing (“last 7 days”, “this month”, etc.)\n✅ Ungrouped queries: Raw row access without aggregation for detail views\n✅ Native YAML format: Complete Sidemantic YAML schema with import/export (see docs/YAML_FORMAT.md)\n✅ Export adapters: Full round-trip support for Sidemantic ↔︎ Cube ↔︎ MetricFlow\n\n\n\n\n\n✅ Display formatting: format and value_format_name on metrics and dimensions\n✅ Drill fields: Define drill-down paths for BI tool integration\n✅ Non-additivity markers: non_additive_dimension to prevent incorrect aggregation\n✅ Default dimensions: default_time_dimension and default_grain for metrics\n✅ Comprehensive metadata: Labels, descriptions on all objects\n\n\n\n\n\n✅ 202 passing tests across all features with comprehensive coverage\n✅ Real DuckDB integration tests\n✅ Round-trip adapter tests (Sidemantic → Cube/MetricFlow → Sidemantic)\n✅ Multi-hop join verification\n✅ Automatic dependency detection tests\n✅ Jinja template integration tests\n✅ Inheritance resolution tests\n✅ Hierarchy navigation tests\n✅ Relative date parsing tests\n✅ Ungrouped query tests\n✅ Segment and metric-level filter tests"
  },
  {
    "objectID": "STATUS.html#to-complete",
    "href": "STATUS.html#to-complete",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "Cumulative metrics: Complete subquery pattern for window functions (basic structure exists, needs proper aggregation-then-window pattern)\nQuery optimization: Add query plan optimization and pushdown strategies\nPre-aggregations: Implement caching layer similar to Cube’s rollups\nLookML adapter: Requires full grammar parser for complete import support"
  },
  {
    "objectID": "STATUS.html#file-structure",
    "href": "STATUS.html#file-structure",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "sidemantic/\n├── sidemantic/\n│   ├── core/\n│   │   ├── dimension.py         ✅ Dimension types with granularity\n│   │   ├── metric.py            ✅ Metric types (ratio, derived, cumulative)\n│   │   ├── model.py             ✅ Model (dataset) definitions\n│   │   ├── relationship.py      ✅ Relationship definitions\n│   │   ├── dependency_analyzer.py ✅ Auto-detect metric dependencies\n│   │   ├── semantic_graph.py    ✅ Graph with join path discovery\n│   │   └── semantic_layer.py    ✅ Main API\n│   ├── sql/\n│   │   ├── generator_v2.py      ✅ SQLGlot builder-based SQL generation\n│   │   └── generator.py         ✅ Legacy SQLGlot AST generator\n│   ├── adapters/\n│   │   ├── base.py              ✅ Base adapter interface\n│   │   ├── sidemantic.py        ✅ Native YAML (import/export)\n│   │   ├── cube.py              ✅ Cube YAML (import/export)\n│   │   ├── metricflow.py        ✅ MetricFlow YAML (import/export)\n│   │   └── lookml.py            ⚠️  LookML (placeholder)\n│   ├── filters/                 📁 Empty (for future filter parsing)\n│   └── api/                     📁 Empty (for future REST API)\n├── tests/\n│   ├── test_basic.py            ✅ Core functionality tests\n│   ├── test_adapters.py         ✅ Adapter import tests\n│   ├── test_sidemantic_adapter.py ✅ Native YAML adapter tests\n│   ├── test_export_adapters.py  ✅ Export and round-trip tests\n│   ├── test_with_data.py        ✅ End-to-end with real DuckDB\n│   ├── test_derived_metrics.py  ✅ Formula parsing tests\n│   ├── test_multi_hop_joins.py  ✅ Multi-hop join tests\n│   ├── test_dependencies.py     ✅ Dependency detection tests\n│   ├── test_validation.py       ✅ Validation tests\n│   └── test_cumulative_metrics.py ⚠️  Window functions (partial)\n├── examples/\n│   ├── basic_example.py         ✅ Usage examples\n│   ├── export_example.py        ✅ Export demonstration\n│   ├── cube/                    📁 Cube YAML examples\n│   ├── metricflow/              📁 MetricFlow YAML examples\n│   └── sidemantic/              📁 Native YAML examples\n└── docs/\n    ├── STATUS.md                📄 This file\n    └── YAML_FORMAT.md           📄 Native YAML format specification"
  },
  {
    "objectID": "STATUS.html#design-decisions",
    "href": "STATUS.html#design-decisions",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "Explicit relationship types (many_to_one, one_to_many, one_to_one) make join semantics clear and prevent ambiguity. No more guessing whether belongs_to means the FK is here or there!\n\n\n\nManual dependency lists are error-prone and redundant. SQL parsing automatically detects what metrics depend on, reducing boilerplate by ~50%.\n\n\n\n\nDialect-agnostic SQL generation\nParse, transform, and transpile SQL across databases\nEnables Snowflake/BigQuery/Postgres compatibility from single codebase\n\n\n\n\n\nMore readable than nested subqueries\nEasier to debug generated SQL\nBetter query optimizer hints on modern databases\n\n\n\n\n\nType safety for semantic model definitions\nValidation out of the box\nJSON/YAML serialization support\nGood IDE autocomplete"
  },
  {
    "objectID": "STATUS.html#next-steps",
    "href": "STATUS.html#next-steps",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "Short-term (to make more useful): 1. Complete cumulative metrics with window functions 2. Add more example YAML files and documentation 3. Performance optimization for large models\nLong-term (to make production-ready): 1. Query caching and optimization 2. REST/GraphQL API layer 3. Pre-aggregation support (like Cube’s rollups) 4. dbt integration 5. Data governance and access control"
  },
  {
    "objectID": "STATUS.html#research-summary",
    "href": "STATUS.html#research-summary",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "The implementation incorporates best practices from:\n\nCube: Pre-aggregations, API-first design, multi-tenancy\nMetricFlow: Semantic graph, metric types\nLookML: Explores/views separation, dimension groups, drill-down\nHex: Multi-format import, interoperability focus\n\nKey insight: All semantic layers share core abstractions (models, dimensions, metrics, relationships) but differ in query optimization, caching, and consumption patterns."
  },
  {
    "objectID": "getting-started.html",
    "href": "getting-started.html",
    "title": "Getting Started",
    "section": "",
    "text": "pip install sidemantic\n# or\nuv add sidemantic"
  },
  {
    "objectID": "getting-started.html#installation",
    "href": "getting-started.html#installation",
    "title": "Getting Started",
    "section": "",
    "text": "pip install sidemantic\n# or\nuv add sidemantic"
  },
  {
    "objectID": "getting-started.html#interactive-demo",
    "href": "getting-started.html#interactive-demo",
    "title": "Getting Started",
    "section": "Interactive Demo",
    "text": "Interactive Demo\nTry the interactive demo locally:\ngit clone https://github.com/sidequery/sidemantic\ncd sidemantic\nuv run marimo run examples/demo.py\nThis opens an interactive notebook where you can explore the semantic layer with real-time queries."
  },
  {
    "objectID": "getting-started.html#your-first-semantic-layer",
    "href": "getting-started.html#your-first-semantic-layer",
    "title": "Getting Started",
    "section": "Your First Semantic Layer",
    "text": "Your First Semantic Layer\n\n1. Define Models (YAML)\nCreate semantic_layer.yml:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n\n    dimensions:\n      - name: order_date\n        type: time\n        sql: order_date\n        granularity: day\n\n      - name: status\n        type: categorical\n        sql: status\n\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n      - name: order_count\n        agg: count\n\n\n2. Query with SQL\nfrom sidemantic import SemanticLayer\n\n# Load semantic layer\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Query with SQL\nresult = layer.sql(\"\"\"\n    SELECT revenue, order_count, status\n    FROM orders\n    WHERE status = 'completed'\n\"\"\")\n\ndf = result.fetchdf()\nprint(df)\n\n\n3. Add Relationships\nDefine relationships between models:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n  - name: customers\n    table: customers\n    primary_key: customer_id\nQuery across models:\n# Automatic join\nresult = layer.sql(\"\"\"\n    SELECT orders.revenue, customers.region\n    FROM orders\n\"\"\")\n\n\n4. Complex Metrics\nAdd graph-level metrics with automatic dependency detection:\nmodels:\n  - name: orders\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n      - name: completed_revenue\n        agg: sum\n        sql: amount\n        filters: [\"status = 'completed'\"]\n\n# Graph-level metrics (dependencies auto-detected!)\nmetrics:\n  # Simple reference\n  - name: total_revenue\n    sql: orders.revenue\n\n  # Ratio\n  - name: conversion_rate\n    type: ratio\n    numerator: orders.completed_revenue\n    denominator: orders.revenue\n\n  # Derived (dependencies auto-detected from formula!)\n  - name: profit_margin\n    type: derived\n    sql: \"(revenue - cost) / revenue\"\n\n  # Cumulative\n  - name: running_total\n    type: cumulative\n    sql: orders.revenue\n    window: \"7 days\""
  },
  {
    "objectID": "getting-started.html#editor-autocomplete",
    "href": "getting-started.html#editor-autocomplete",
    "title": "Getting Started",
    "section": "Editor Autocomplete",
    "text": "Editor Autocomplete\nGenerate JSON Schema for IDE support:\nuv run python -m sidemantic.schema\nThis creates sidemantic-schema.json. Add to your YAML:\n# yaml-language-server: $schema=./sidemantic-schema.json\nNow get autocomplete in VS Code, IntelliJ, and other editors!"
  },
  {
    "objectID": "getting-started.html#next-steps",
    "href": "getting-started.html#next-steps",
    "title": "Getting Started",
    "section": "Next Steps",
    "text": "Next Steps\n\nExamples - Real-world use cases\nYAML Reference - Complete specification\nGOTCHAS - Common pitfalls and solutions"
  },
  {
    "objectID": "joins.html",
    "href": "joins.html",
    "title": "Joins",
    "section": "",
    "text": "Define relationships between models for automatic joining."
  },
  {
    "objectID": "joins.html#join-types",
    "href": "joins.html#join-types",
    "title": "Joins",
    "section": "Join Types",
    "text": "Join Types\n\nbelongs_to\nThe foreign key is in THIS model:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: id\n    joins:\n      - name: customers\n        type: belongs_to\n        foreign_key: customer_id  # Column in orders table\nSQL: LEFT JOIN customers ON orders.customer_id = customers.id\n\n\nhas_many\nThe foreign key is in the OTHER model:\nmodels:\n  - name: customers\n    table: customers\n    primary_key: id\n    joins:\n      - name: orders\n        type: has_many\n        foreign_key: customer_id  # Column in orders table\nSQL: LEFT JOIN orders ON customers.id = orders.customer_id\n\n\nhas_one\nLike has_many but expects one record:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: id\n    joins:\n      - name: invoice\n        type: has_one\n        foreign_key: order_id  # Column in invoice table\nSQL: LEFT JOIN invoice ON orders.id = invoice.order_id"
  },
  {
    "objectID": "joins.html#bidirectional-joins",
    "href": "joins.html#bidirectional-joins",
    "title": "Joins",
    "section": "Bidirectional Joins",
    "text": "Bidirectional Joins\nDefine from both sides for flexibility:\nmodels:\n  - name: orders\n    joins:\n      - name: customers\n        type: belongs_to\n        foreign_key: customer_id\n\n  - name: customers\n    joins:\n      - name: orders\n        type: has_many\n        foreign_key: customer_id\nNow you can query from either direction: - SELECT orders.revenue, customers.name FROM orders - SELECT customers.name, orders.revenue FROM customers"
  },
  {
    "objectID": "joins.html#multi-hop-joins",
    "href": "joins.html#multi-hop-joins",
    "title": "Joins",
    "section": "Multi-Hop Joins",
    "text": "Multi-Hop Joins\nDefine relationships and query across 2+ models automatically:\nmodels:\n  - name: orders\n    joins:\n      - name: customers\n        type: belongs_to\n        foreign_key: customer_id\n\n  - name: customers\n    joins:\n      - name: regions\n        type: belongs_to\n        foreign_key: region_id\n\n  - name: regions\n    table: regions\n    primary_key: id\nQuery spans 2 hops automatically:\n# orders -&gt; customers -&gt; regions\nlayer.sql(\"\"\"\n    SELECT orders.revenue, regions.country\n    FROM orders\n\"\"\")"
  },
  {
    "objectID": "joins.html#join-properties",
    "href": "joins.html#join-properties",
    "title": "Joins",
    "section": "Join Properties",
    "text": "Join Properties\n\nname: Name of the related model\ntype: belongs_to, has_many, or has_one\nforeign_key: The foreign key column name"
  },
  {
    "objectID": "joins.html#python-api",
    "href": "joins.html#python-api",
    "title": "Joins",
    "section": "Python API",
    "text": "Python API\nfrom sidemantic import Model, Join\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"id\",\n    joins=[\n        Join(name=\"customers\", type=\"belongs_to\", foreign_key=\"customer_id\"),\n        Join(name=\"order_items\", type=\"has_many\", foreign_key=\"order_id\")\n    ]\n)\n\ncustomers = Model(\n    name=\"customers\",\n    table=\"customers\",\n    primary_key=\"id\",\n    joins=[\n        Join(name=\"orders\", type=\"has_many\", foreign_key=\"customer_id\")\n    ]\n)"
  },
  {
    "objectID": "joins.html#symmetric-aggregates",
    "href": "joins.html#symmetric-aggregates",
    "title": "Joins",
    "section": "Symmetric Aggregates",
    "text": "Symmetric Aggregates\nWhen you have fan-out (one-to-many joins), Sidemantic automatically uses symmetric aggregates to prevent double-counting:\nmodels:\n  - name: orders\n    measures:\n      - name: revenue\n        agg: sum\n        expr: amount\n\n    joins:\n      - name: order_items\n        type: has_many\n        foreign_key: order_id\n# Query with fan-out\nlayer.sql(\"\"\"\n    SELECT orders.revenue, order_items.quantity\n    FROM orders\n\"\"\")\nAutomatically generates:\nSUM(DISTINCT HASH(orders.id)::HUGEINT * (1::HUGEINT &lt;&lt; 20) + orders.revenue)\nThis ensures revenue is counted once per order, not once per item."
  },
  {
    "objectID": "joins.html#best-practices",
    "href": "joins.html#best-practices",
    "title": "Joins",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipForeign Key Rules\n\n\n\n\nbelongs_to: foreign_key is in THIS table\nhas_many: foreign_key is in the OTHER table\nhas_one: foreign_key is in the OTHER table (unique)\n\n\n\n\n\n\n\n\n\nWarningPrimary Keys Required\n\n\n\nSet primary_key on all models involved in joins:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: id  # Required!\n\n\n\n\n\n\n\n\nTipDefine Both Sides\n\n\n\nFor maximum flexibility, define joins from both models:\n# orders -&gt; customers\n- name: orders\n  joins:\n    - name: customers\n      type: belongs_to\n      foreign_key: customer_id\n\n# customers -&gt; orders\n- name: customers\n  joins:\n    - name: orders\n      type: has_many\n      foreign_key: customer_id"
  },
  {
    "objectID": "joins.html#common-patterns",
    "href": "joins.html#common-patterns",
    "title": "Joins",
    "section": "Common Patterns",
    "text": "Common Patterns\n\nOne-to-Many\n# Order has many items\n- name: orders\n  joins:\n    - name: order_items\n      type: has_many\n      foreign_key: order_id\n\n# Item belongs to order\n- name: order_items\n  joins:\n    - name: orders\n      type: belongs_to\n      foreign_key: order_id\n\n\nMany-to-One\n# Order belongs to customer\n- name: orders\n  joins:\n    - name: customers\n      type: belongs_to\n      foreign_key: customer_id\n\n# Customer has many orders\n- name: customers\n  joins:\n    - name: orders\n      type: has_many\n      foreign_key: customer_id\n\n\nOne-to-One\n# Order has one invoice\n- name: orders\n  joins:\n    - name: invoice\n      type: has_one\n      foreign_key: order_id\n\n# Invoice belongs to order\n- name: invoice\n  joins:\n    - name: orders\n      type: belongs_to\n      foreign_key: order_id"
  },
  {
    "objectID": "joins.html#troubleshooting",
    "href": "joins.html#troubleshooting",
    "title": "Joins",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\n\n\n\n\n\nWarning“No join path found”\n\n\n\nEnsure you’ve defined joins between the models:\nmodels:\n  - name: orders\n    joins:\n      - name: customers\n        type: belongs_to\n        foreign_key: customer_id\n\n\n\n\n\n\n\n\nWarningWrong foreign_key\n\n\n\nIf joins aren’t working, check the foreign_key: - belongs_to: Column in THIS table - has_many/has_one: Column in OTHER table"
  },
  {
    "objectID": "YAML_FORMAT.html#metrics-model-level",
    "href": "YAML_FORMAT.html#metrics-model-level",
    "title": "YAML Format Reference",
    "section": "",
    "text": "Model-level metrics are aggregations defined on a single model. These become the building blocks for graph-level metrics.\n\n\nmetrics:\n  - name: string              # Required\n    agg: sum|count|count_distinct|avg|min|max|median  # Required\n    sql: string               # SQL expression (defaults to * for count)\n    filters: [string]         # Optional WHERE conditions\n    description: string       # Optional\n    fill_nulls_with: value    # Optional default for NULL\n\n\n\nmetrics:\n  # Simple sum\n  - name: revenue\n    agg: sum\n    sql: amount\n\n  # Count\n  - name: order_count\n    agg: count\n\n  # Average\n  - name: avg_order_value\n    agg: avg\n    sql: amount\n\n  # With filter\n  - name: completed_revenue\n    agg: sum\n    sql: amount\n    filters: [\"status = 'completed'\"]\n\n  # SQL expression\n  - name: total_value\n    agg: sum\n    sql: \"quantity * price * (1 - discount)\"\n\n  # Multiple filters\n  - name: us_revenue\n    agg: sum\n    sql: amount\n    filters:\n      - \"country = 'US'\"\n      - \"amount &gt; 0\""
  },
  {
    "objectID": "YAML_FORMAT.html#metrics-graph-level",
    "href": "YAML_FORMAT.html#metrics-graph-level",
    "title": "YAML Format Reference",
    "section": "",
    "text": "Graph-level metrics are defined at the top level and can reference model-level metrics or other graph-level metrics. Dependencies are auto-detected from SQL expressions.\n\n\nThe simplest graph-level metric just references a model-level metric:\nmetrics:\n  # Reference a model-level metric\n  - name: total_revenue\n    sql: orders.revenue\n    description: \"Total revenue from all orders\"\nNo type needed! Dependencies are automatically detected from the sql expression.\n\n\n\nmetrics:\n  - name: conversion_rate\n    type: ratio\n    numerator: orders.completed_revenue\n    denominator: orders.revenue\n\n\n\nDerived metrics use formulas and automatically detect dependencies:\nmetrics:\n  # Simple formula - dependencies auto-detected\n  - name: profit\n    type: derived\n    sql: \"revenue - cost\"\n\n  # References other metrics - no manual dependency list needed!\n  - name: revenue_per_customer\n    type: derived\n    sql: \"total_revenue / total_customers\"\n\n\n\nmetrics:\n  # Rolling window\n  - name: rolling_7day_revenue\n    type: cumulative\n    sql: orders.revenue\n    window: \"7 days\"\n\n  # Period-to-date (MTD, YTD, etc.)\n  - name: mtd_revenue\n    type: cumulative\n    sql: orders.revenue\n    grain_to_date: month\n\n\n\nmetrics:\n  - name: yoy_revenue_growth\n    type: time_comparison\n    base_metric: total_revenue\n    comparison_type: yoy          # yoy, mom, wow, qoq\n    calculation: percent_change   # percent_change, difference, ratio\n\n\n\nmetrics:\n  - name: signup_to_purchase_rate\n    type: conversion\n    entity: user_id\n    base_event: signup\n    conversion_event: purchase\n    conversion_window: \"7 days\""
  },
  {
    "objectID": "YAML_FORMAT.html#relationships",
    "href": "YAML_FORMAT.html#relationships",
    "title": "YAML Format Reference",
    "section": "",
    "text": "Relationships define how models join together. Use explicit relationship types instead of traditional join terminology.\nrelationships:\n  - name: string              # Required - name of related model\n    type: many_to_one|one_to_many|one_to_one  # Required\n    foreign_key: string       # Required - FK column name\n    primary_key: string       # Optional - PK in related table (defaults to related model's primary_key)\n\n\n\nmany_to_one: Many records in THIS table → one record in OTHER table (e.g., orders → customer)\none_to_many: One record in THIS table → many records in OTHER table (e.g., customer → orders)\none_to_one: One record in THIS table → one record in OTHER table (e.g., order → invoice)\n\n\n\n\nmodels:\n  # Orders: many orders belong to one customer\n  - name: orders\n    table: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id  # Column in orders table\n\n  # Customers: one customer has many orders\n  - name: customers\n    table: customers\n    primary_key: customer_id\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id  # Column in orders table (the OTHER table)\n\n  # Order has one invoice\n  - name: orders\n    relationships:\n      - name: invoice\n        type: one_to_one\n        foreign_key: order_id     # Column in invoice table"
  },
  {
    "objectID": "STATUS.html#recent-dsl-improvements-2025-01",
    "href": "STATUS.html#recent-dsl-improvements-2025-01",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "✅ Removed entity system: Use primary_key directly on models (simpler!)\n✅ Renamed joins → relationships: Explicit types (many_to_one, one_to_many, one_to_one)\n✅ Standardized field names: All expr → sql consistently\n✅ Unified terminology: measures → metrics everywhere\n✅ Auto-detect dependencies: No more type: simple or manual dependency lists!\n\nBefore:\nmodels:\n  - name: orders\n    entities:\n      - name: order\n        type: primary\n        expr: order_id\n      - name: customer\n        type: foreign\n        expr: customer_id\n    joins:\n      - name: customers\n        type: belongs_to\n        foreign_key: customer_id\n    measures:\n      - name: revenue\n        agg: sum\n        expr: amount\n\nmetrics:\n  - name: total_revenue\n    type: simple\n    measure: orders.revenue\nAfter:\nmodels:\n  - name: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\nmetrics:\n  # Dependencies auto-detected!\n  - name: total_revenue\n    sql: orders.revenue\nResult: Cleaner, more intuitive DSL with automatic dependency detection!"
  },
  {
    "objectID": "STATUS.html#sql-generation-examples",
    "href": "STATUS.html#sql-generation-examples",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "Example Output:\nWITH orders_cte AS (\n  SELECT\n    order_id AS order_id,\n    customer_id AS customer_id,\n    status AS status,\n    order_amount AS revenue_raw\n  FROM public.orders\n)\nSELECT\n  orders_cte.status AS status,\n  SUM(orders_cte.revenue_raw) AS revenue\nFROM orders_cte\nGROUP BY 1"
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "Metrics",
    "section": "",
    "text": "Metrics define how to aggregate and calculate measures. Sidemantic distinguishes between model-level metrics (aggregations) and graph-level metrics (formulas/references)."
  },
  {
    "objectID": "metrics.html#model-level-metrics",
    "href": "metrics.html#model-level-metrics",
    "title": "Metrics",
    "section": "Model-Level Metrics",
    "text": "Model-Level Metrics\nModel-level metrics are aggregations defined on a single model. These become building blocks for graph-level metrics.\n\nSimple Aggregations\nBasic aggregations on a single column:\nmodels:\n  - name: orders\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n      - name: order_count\n        agg: count\n\n      - name: avg_price\n        agg: avg\n        sql: price\n\n      - name: max_amount\n        agg: max\n        sql: amount\nAvailable aggregations: sum, count, count_distinct, avg, min, max, median\n\n\nFiltered Metrics\nApply filters to specific metrics:\nmetrics:\n  - name: completed_revenue\n    agg: sum\n    sql: amount\n    filters: [\"status = 'completed'\"]\n\n  - name: us_orders\n    agg: count\n    filters: [\"country = 'US'\", \"amount &gt; 0\"]\nFilters are ANDed together.\n\n\nSQL Expressions\nMetrics support full SQL expressions:\nmetrics:\n  - name: total_value\n    agg: sum\n    sql: \"quantity * price * (1 - discount_pct)\""
  },
  {
    "objectID": "metrics.html#graph-level-metrics",
    "href": "metrics.html#graph-level-metrics",
    "title": "Metrics",
    "section": "Graph-Level Metrics",
    "text": "Graph-Level Metrics\nGraph-level metrics are defined at the top level and can reference model-level metrics or other graph-level metrics. Dependencies are auto-detected!\n\nMetric References\nThe simplest graph-level metric references a model-level metric:\nmetrics:\n  # Dependencies auto-detected from sql!\n  - name: total_revenue\n    sql: orders.revenue\n    description: \"Total revenue from all orders\"\nNo type field needed - dependencies are automatically detected from the sql expression.\n\n\nRatio Metrics\nDivide one metric by another:\nmetrics:\n  - name: conversion_rate\n    type: ratio\n    numerator: orders.completed_revenue\n    denominator: orders.revenue\n\n  - name: profit_margin\n    type: ratio\n    numerator: orders.profit\n    denominator: orders.revenue\nResults in: numerator / NULLIF(denominator, 0)\n\n\nDerived Metrics\nFormula-based calculations with automatic dependency detection:\nmetrics:\n  # Dependencies auto-detected!\n  - name: profit\n    type: derived\n    sql: \"revenue - cost\"\n\n  - name: margin_pct\n    type: derived\n    sql: \"(revenue - cost) / revenue * 100\"\n\n  - name: revenue_per_customer\n    type: derived\n    sql: \"total_revenue / total_customers\"\nNo need to manually list dependencies - they’re extracted from the SQL expression!\n\n\nCumulative Metrics\nRunning totals and period-to-date:\nmetrics:\n  # Rolling window\n  - name: last_7_days_revenue\n    type: cumulative\n    sql: orders.revenue\n    window: \"7 days\"\n\n  # Month-to-date\n  - name: mtd_revenue\n    type: cumulative\n    sql: orders.revenue\n    grain_to_date: month\n\n  # Year-to-date\n  - name: ytd_revenue\n    type: cumulative\n    sql: orders.revenue\n    grain_to_date: year\nRequires a time dimension in the query.\n\n\nTime Comparison Metrics\nYear-over-year, month-over-month changes:\nmetrics:\n  # Year-over-year growth\n  - name: yoy_revenue_growth\n    type: time_comparison\n    base_metric: total_revenue\n    comparison_type: yoy\n    calculation: percent_change\n\n  # Month-over-month\n  - name: mom_revenue\n    type: time_comparison\n    base_metric: total_revenue\n    comparison_type: mom\n    calculation: difference\n\n  # Custom offset\n  - name: vs_last_quarter\n    type: time_comparison\n    base_metric: total_revenue\n    time_offset: \"3 months\"\n    calculation: ratio\nCalculation types: - percent_change: (current - prior) / prior * 100 - difference: current - prior - ratio: current / prior\n\n\nConversion Metrics\nTrack funnel conversions:\nmetrics:\n  - name: signup_to_purchase\n    type: conversion\n    entity: user_id\n    base_event: signup\n    conversion_event: purchase\n    conversion_window: \"7 days\"\nCalculates: users who did conversion_event within window after base_event / total users who did base_event"
  },
  {
    "objectID": "metrics.html#metric-properties",
    "href": "metrics.html#metric-properties",
    "title": "Metrics",
    "section": "Metric Properties",
    "text": "Metric Properties\n\nModel-Level Metrics\n\nname: Unique identifier\nagg: Aggregation function (sum, count, avg, etc.)\nsql: SQL expression to aggregate (defaults to * for count)\nfilters: WHERE conditions for this metric\ndescription: Human-readable description\nlabel: Display name (defaults to name)\n\n\n\nGraph-Level Metrics\n\nUntyped (Metric References)\n\nname: Unique identifier\nsql: Reference to model.metric (e.g., “orders.revenue”)\ndescription: Human-readable description\n\n\n\nTyped Metrics\n\ntype: Metric type (ratio, derived, cumulative, time_comparison, conversion)\nType-specific properties (see sections above)\n\n\n\n\nNull Handling\nmetrics:\n  - name: revenue\n    agg: sum\n    sql: amount\n    fill_nulls_with: 0  # Return 0 instead of NULL"
  },
  {
    "objectID": "metrics.html#python-api",
    "href": "metrics.html#python-api",
    "title": "Metrics",
    "section": "Python API",
    "text": "Python API\nfrom sidemantic import Metric\n\n# Model-level: Simple aggregation\nrevenue = Metric(name=\"revenue\", agg=\"sum\", sql=\"amount\")\n\n# Model-level: Filtered\ncompleted = Metric(\n    name=\"completed_revenue\",\n    agg=\"sum\",\n    sql=\"amount\",\n    filters=[\"status = 'completed'\"]\n)\n\n# Graph-level: Reference (dependencies auto-detected!)\ntotal_revenue = Metric(\n    name=\"total_revenue\",\n    sql=\"orders.revenue\"\n)\n\n# Graph-level: Ratio\nmargin = Metric(\n    name=\"margin\",\n    type=\"ratio\",\n    numerator=\"orders.profit\",\n    denominator=\"orders.revenue\"\n)\n\n# Graph-level: Derived (dependencies auto-detected!)\nprofit = Metric(\n    name=\"profit\",\n    type=\"derived\",\n    sql=\"revenue - cost\"\n)\n\n# Graph-level: Cumulative\nrunning_total = Metric(\n    name=\"running_total\",\n    type=\"cumulative\",\n    sql=\"orders.revenue\",\n    window=\"7 days\"\n)"
  },
  {
    "objectID": "metrics.html#best-practices",
    "href": "metrics.html#best-practices",
    "title": "Metrics",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipStart Simple\n\n\n\nDefine basic aggregations first, then build complex metrics on top: 1. Model-level metrics (revenue, count) 2. Filtered metrics (completed_revenue) 3. Graph-level references (total_revenue) 4. Ratios (conversion_rate = completed / total) 5. Derived (margin = profit / revenue)\n\n\n\n\n\n\n\n\nTipAuto-Detected Dependencies\n\n\n\nNo need to manually declare dependencies! They’re automatically extracted from sql expressions:\n# Old way (manual dependencies - deprecated)\n- name: profit_margin\n  type: derived\n  sql: \"profit / revenue\"\n  metrics: [\"profit\", \"revenue\"]  # Don't need this!\n\n# New way (auto-detected)\n- name: profit_margin\n  type: derived\n  sql: \"profit / revenue\"  # Dependencies detected automatically!\n\n\n\n\n\n\n\n\nTipReusability\n\n\n\nDefine metrics once, use everywhere: - In SQL queries: SELECT revenue FROM orders - In Python: layer.query(metrics=[\"orders.revenue\"]) - In other metrics: sql: \"revenue - cost\""
  },
  {
    "objectID": "relationships.html",
    "href": "relationships.html",
    "title": "Relationships",
    "section": "",
    "text": "Define relationships between models for automatic joining."
  },
  {
    "objectID": "relationships.html#relationship-types",
    "href": "relationships.html#relationship-types",
    "title": "Relationships",
    "section": "Relationship Types",
    "text": "Relationship Types\n\nmany_to_one\nMany records in THIS model → one record in OTHER model:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id  # Column in orders table\nSQL: LEFT JOIN customers ON orders.customer_id = customers.customer_id\nMeaning: Many orders belong to one customer.\n\n\none_to_many\nOne record in THIS model → many records in OTHER model:\nmodels:\n  - name: customers\n    table: customers\n    primary_key: customer_id\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id  # Column in orders table (the OTHER table)\nSQL: LEFT JOIN orders ON customers.customer_id = orders.customer_id\nMeaning: One customer has many orders.\n\n\none_to_one\nOne record in THIS model → one record in OTHER model:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    relationships:\n      - name: invoice\n        type: one_to_one\n        foreign_key: order_id  # Column in invoice table\nSQL: LEFT JOIN invoice ON orders.order_id = invoice.order_id\nMeaning: One order has one invoice."
  },
  {
    "objectID": "relationships.html#bidirectional-relationships",
    "href": "relationships.html#bidirectional-relationships",
    "title": "Relationships",
    "section": "Bidirectional Relationships",
    "text": "Bidirectional Relationships\nDefine from both sides for flexibility:\nmodels:\n  - name: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n  - name: customers\n    primary_key: customer_id\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id\nNow you can query from either direction: - SELECT orders.revenue, customers.name FROM orders - SELECT customers.name, orders.revenue FROM customers"
  },
  {
    "objectID": "relationships.html#multi-hop-joins",
    "href": "relationships.html#multi-hop-joins",
    "title": "Relationships",
    "section": "Multi-Hop Joins",
    "text": "Multi-Hop Joins\nDefine relationships and query across 2+ models automatically:\nmodels:\n  - name: orders\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n  - name: customers\n    relationships:\n      - name: region\n        type: many_to_one\n        foreign_key: region_id\n\n  - name: regions\n    table: regions\n    primary_key: region_id\nQuery spans 2 hops automatically:\n# orders -&gt; customers -&gt; regions\nlayer.sql(\"\"\"\n    SELECT orders.revenue, regions.country\n    FROM orders\n\"\"\")"
  },
  {
    "objectID": "relationships.html#relationship-properties",
    "href": "relationships.html#relationship-properties",
    "title": "Relationships",
    "section": "Relationship Properties",
    "text": "Relationship Properties\n\nname: Name of the related model\ntype: many_to_one, one_to_many, or one_to_one\nforeign_key: The foreign key column name\nprimary_key: (Optional) Primary key in related table (defaults to related model’s primary_key)"
  },
  {
    "objectID": "relationships.html#python-api",
    "href": "relationships.html#python-api",
    "title": "Relationships",
    "section": "Python API",
    "text": "Python API\nfrom sidemantic import Model, Relationship\n\norders = Model(\n    name=\"orders\",\n    table=\"orders\",\n    primary_key=\"order_id\",\n    relationships=[\n        Relationship(name=\"customer\", type=\"many_to_one\", foreign_key=\"customer_id\"),\n        Relationship(name=\"order_items\", type=\"one_to_many\", foreign_key=\"order_id\")\n    ]\n)\n\ncustomers = Model(\n    name=\"customers\",\n    table=\"customers\",\n    primary_key=\"customer_id\",\n    relationships=[\n        Relationship(name=\"orders\", type=\"one_to_many\", foreign_key=\"customer_id\")\n    ]\n)"
  },
  {
    "objectID": "relationships.html#symmetric-aggregates",
    "href": "relationships.html#symmetric-aggregates",
    "title": "Relationships",
    "section": "Symmetric Aggregates",
    "text": "Symmetric Aggregates\nWhen you have fan-out (one-to-many joins), Sidemantic automatically uses symmetric aggregates to prevent double-counting:\nmodels:\n  - name: orders\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\n    relationships:\n      - name: order_items\n        type: one_to_many\n        foreign_key: order_id\n# Query with fan-out\nlayer.sql(\"\"\"\n    SELECT orders.revenue, order_items.quantity\n    FROM orders\n\"\"\")\nAutomatically generates:\nSUM(DISTINCT HASH(orders.order_id)::HUGEINT * (1::HUGEINT &lt;&lt; 20) + orders.revenue)\nThis ensures revenue is counted once per order, not once per item."
  },
  {
    "objectID": "relationships.html#best-practices",
    "href": "relationships.html#best-practices",
    "title": "Relationships",
    "section": "Best Practices",
    "text": "Best Practices\n\n\n\n\n\n\nTipUnderstanding Relationship Types\n\n\n\n\nmany_to_one: FK is in THIS table (e.g., orders.customer_id)\none_to_many: FK is in the OTHER table (e.g., customers ← orders.customer_id)\none_to_one: FK is in the OTHER table, expects one record\n\n\n\n\n\n\n\n\n\nWarningPrimary Keys Required\n\n\n\nSet primary_key on all models involved in relationships:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id  # Required!\n\n\n\n\n\n\n\n\nTipDefine Both Sides\n\n\n\nFor maximum flexibility, define relationships from both models:\n# orders -&gt; customers (many-to-one)\n- name: orders\n  relationships:\n    - name: customer\n      type: many_to_one\n      foreign_key: customer_id\n\n# customers -&gt; orders (one-to-many)\n- name: customers\n  relationships:\n    - name: orders\n      type: one_to_many\n      foreign_key: customer_id"
  },
  {
    "objectID": "relationships.html#common-patterns",
    "href": "relationships.html#common-patterns",
    "title": "Relationships",
    "section": "Common Patterns",
    "text": "Common Patterns\n\nOne-to-Many\n# Order has many items\n- name: orders\n  primary_key: order_id\n  relationships:\n    - name: order_items\n      type: one_to_many\n      foreign_key: order_id\n\n# Item belongs to order (inverse: many-to-one)\n- name: order_items\n  primary_key: item_id\n  relationships:\n    - name: order\n      type: many_to_one\n      foreign_key: order_id\n\n\nMany-to-One\n# Order belongs to customer\n- name: orders\n  primary_key: order_id\n  relationships:\n    - name: customer\n      type: many_to_one\n      foreign_key: customer_id\n\n# Customer has many orders (inverse: one-to-many)\n- name: customers\n  primary_key: customer_id\n  relationships:\n    - name: orders\n      type: one_to_many\n      foreign_key: customer_id\n\n\nOne-to-One\n# Order has one invoice\n- name: orders\n  primary_key: order_id\n  relationships:\n    - name: invoice\n      type: one_to_one\n      foreign_key: order_id\n\n# Invoice belongs to order (inverse: many-to-one, but unique)\n- name: invoice\n  primary_key: invoice_id\n  relationships:\n    - name: order\n      type: many_to_one\n      foreign_key: order_id"
  },
  {
    "objectID": "relationships.html#migration-from-joins",
    "href": "relationships.html#migration-from-joins",
    "title": "Relationships",
    "section": "Migration from Joins",
    "text": "Migration from Joins\nIf you’re upgrading from the old joins syntax:\nOld (deprecated):\njoins:\n  - name: customers\n    type: belongs_to\n    foreign_key: customer_id\nNew:\nrelationships:\n  - name: customer\n    type: many_to_one\n    foreign_key: customer_id\nType mapping: - belongs_to → many_to_one (FK in THIS table) - has_many → one_to_many (FK in OTHER table) - has_one → one_to_one (FK in OTHER table, unique)"
  },
  {
    "objectID": "relationships.html#troubleshooting",
    "href": "relationships.html#troubleshooting",
    "title": "Relationships",
    "section": "Troubleshooting",
    "text": "Troubleshooting\n\n\n\n\n\n\nWarning“No join path found”\n\n\n\nEnsure you’ve defined relationships between the models:\nmodels:\n  - name: orders\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n\n\n\n\n\n\n\nWarningWrong foreign_key\n\n\n\nIf joins aren’t working, check the foreign_key: - many_to_one: Column in THIS table - one_to_many/one_to_one: Column in OTHER table"
  },
  {
    "objectID": "models.html#metrics-model-level",
    "href": "models.html#metrics-model-level",
    "title": "Models",
    "section": "Metrics (Model-Level)",
    "text": "Metrics (Model-Level)\nModel-level metrics define aggregations on a single model:\nmodels:\n  - name: orders\n    metrics:\n      # Simple aggregations\n      - name: revenue\n        agg: sum\n        sql: amount\n\n      - name: order_count\n        agg: count\n\n      - name: avg_order_value\n        agg: avg\n        sql: amount\n\n      # With filters\n      - name: completed_revenue\n        agg: sum\n        sql: amount\n        filters: [\"status = 'completed'\"]\n\n      # SQL expressions\n      - name: total_value\n        agg: sum\n        sql: \"quantity * price\"\n\nAggregation Types\n\nsum: Sum values\ncount: Count rows\ncount_distinct: Count unique values\navg: Average\nmin: Minimum value\nmax: Maximum value\nmedian: Median value\n\nSee Metrics for graph-level metrics (ratios, derived, cumulative)."
  },
  {
    "objectID": "models.html#relationships",
    "href": "models.html#relationships",
    "title": "Models",
    "section": "Relationships",
    "text": "Relationships\nDefine how models join to each other:\nmodels:\n  - name: orders\n    table: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n\n  - name: customers\n    table: customers\n    primary_key: customer_id\n    relationships:\n      - name: orders\n        type: one_to_many\n        foreign_key: customer_id\nSee Relationships for details."
  },
  {
    "objectID": "python-api.html#metric",
    "href": "python-api.html#metric",
    "title": "Python API",
    "section": "Metric",
    "text": "Metric\nDefine a metric:\nfrom sidemantic import Metric\n\n# Simple aggregation\nrevenue = Metric(\n    name=\"revenue\",\n    agg=\"sum\",\n    expr=\"amount\"\n)\n\n# With metric-level filter (auto-applied in WHERE clause)\ncompleted_revenue = Metric(\n    name=\"completed_revenue\",\n    agg=\"sum\",\n    expr=\"amount\",\n    filters=[\"{model}.status = 'completed'\"]\n)\n\n# Ratio\nconversion_rate = Metric(\n    name=\"conversion_rate\",\n    type=\"ratio\",\n    numerator=\"completed_orders\",\n    denominator=\"total_orders\"\n)\n\n# Derived\nprofit = Metric(\n    name=\"profit\",\n    type=\"derived\",\n    expr=\"revenue - cost\"\n)\n\n# Cumulative\nrunning_total = Metric(\n    name=\"running_total\",\n    type=\"cumulative\",\n    expr=\"revenue\",\n    window=\"7 days\"\n)\n\n# Time comparison\nyoy_growth = Metric(\n    name=\"yoy_growth\",\n    type=\"time_comparison\",\n    base_metric=\"revenue\",\n    comparison_type=\"yoy\",\n    calculation=\"percent_change\"\n)\n\n# With Jinja2 template\nconditional_revenue = Metric(\n    name=\"conditional_revenue\",\n    agg=\"sum\",\n    expr=\"\"\"\n    {% if include_tax %}\n        amount * 1.1\n    {% else %}\n        amount\n    {% endif %}\n    \"\"\"\n)\n\n# With metadata\nformatted_revenue = Metric(\n    name=\"formatted_revenue\",\n    agg=\"sum\",\n    expr=\"amount\",\n    format=\"$#,##0.00\",\n    value_format_name=\"usd\",\n    drill_fields=[\"order_id\", \"customer_id\", \"order_date\"],\n    non_additive_dimension=\"customer_id\",\n    default_time_dimension=\"order_date\",\n    default_grain=\"day\"\n)\n\n# With inheritance\nextended_revenue = Metric(\n    name=\"extended_revenue\",\n    extends=\"base_revenue\",  # Inherit from parent metric\n    filters=[\"{model}.region = 'US'\"]\n)\n\nProperties\n\nSimple Aggregations\n\nname: Unique identifier\nagg: sum, count, count_distinct, avg, min, max, median\nexpr: SQL expression (defaults to * for count)\nfilters: List of WHERE conditions (auto-applied when metric is used)\ndescription: Human-readable description\n\n\n\nRatio Metrics\n\ntype: \"ratio\"\nnumerator: Numerator metric name\ndenominator: Denominator metric name\noffset_window: Time offset for denominator (e.g., \"1 month\")\n\n\n\nDerived Metrics\n\ntype: \"derived\"\nexpr: Formula expression (can reference other metrics)\n\n\n\nCumulative Metrics\n\ntype: \"cumulative\"\nexpr: Base metric name\nwindow: Rolling window (e.g., \"7 days\")\ngrain_to_date: Period-to-date (day, week, month, quarter, year)\n\n\n\nTime Comparison Metrics\n\ntype: \"time_comparison\"\nbase_metric: Base metric name\ncomparison_type: yoy, mom, wow, dod, qoq, prior_period\ntime_offset: Custom offset (e.g., \"3 months\")\ncalculation: percent_change, difference, or ratio\n\n\n\nMetadata Fields\n\nformat: Display format string (e.g., \"$#,##0.00\", \"0.00%\")\nvalue_format_name: Named format (e.g., \"usd\", \"percent\")\ndrill_fields: List of field names for drill-down\nnon_additive_dimension: Dimension this metric cannot be summed across\ndefault_time_dimension: Default time dimension for this metric\ndefault_grain: Default time granularity (hour, day, week, month, quarter, year)\n\n\n\nInheritance\n\nextends: Parent metric to inherit from"
  },
  {
    "objectID": "python-api.html#relationship",
    "href": "python-api.html#relationship",
    "title": "Python API",
    "section": "Relationship",
    "text": "Relationship\nDefine join relationships:\nfrom sidemantic import Relationship\n\n# many_to_one (foreign key in THIS table)\ncustomers_join = Relationship(\n    name=\"customers\",\n    type=\"many_to_one\",\n    foreign_key=\"customer_id\"\n)\n\n# one_to_many (foreign key in OTHER table)\norders_join = Relationship(\n    name=\"orders\",\n    type=\"one_to_many\",\n    foreign_key=\"customer_id\"\n)\n\n# one_to_one (foreign key in OTHER table, unique)\ninvoice_join = Relationship(\n    name=\"invoice\",\n    type=\"one_to_one\",\n    foreign_key=\"order_id\"\n)\n\n# Custom primary key\nregion_join = Relationship(\n    name=\"region_map\",\n    type=\"many_to_one\",\n    foreign_key=\"region\",\n    primary_key=\"region_code\"\n)\n\nProperties\n\nname: Name of related model\ntype: many_to_one, one_to_many, or one_to_one\nforeign_key: Foreign key column name\nprimary_key: Primary key in related model (default: “id”)"
  },
  {
    "objectID": "STATUS.html#future-work",
    "href": "STATUS.html#future-work",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "Query optimization: Add query plan optimization and pushdown strategies\nPre-aggregations: Implement caching layer similar to Cube’s rollups\nLookML adapter: Requires full grammar parser for complete import support"
  },
  {
    "objectID": "STATUS.html#dsl-design",
    "href": "STATUS.html#dsl-design",
    "title": "Sidemantic Implementation Status",
    "section": "",
    "text": "Simple primary keys: Use primary_key directly on models\nExplicit relationships: Clear types (many_to_one, one_to_many, one_to_one)\nConsistent field names: sql everywhere for expressions\nUnified terminology: metrics consistently\nAuto-detected dependencies: No manual dependency lists needed\n\nExample:\nmodels:\n  - name: orders\n    primary_key: order_id\n    relationships:\n      - name: customer\n        type: many_to_one\n        foreign_key: customer_id\n    metrics:\n      - name: revenue\n        agg: sum\n        sql: amount\n\nmetrics:\n  # Dependencies auto-detected!\n  - name: total_revenue\n    sql: orders.revenue"
  },
  {
    "objectID": "advanced-features.html",
    "href": "advanced-features.html",
    "title": "Advanced Features",
    "section": "",
    "text": "Define named filters that can be reused across queries:\nmodels:\n  - name: orders\n    table: orders\n    segments:\n      - name: completed\n        sql: \"{model}.status = 'completed'\"\n        description: \"Only completed orders\"\n\n      - name: high_value\n        sql: \"{model}.amount &gt; 100\"\n        description: \"High value orders\"\nUse in queries:\nsql = layer.compile(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.region\"],\n    segments=[\"orders.completed\", \"orders.high_value\"]\n)\nThe {model} placeholder gets replaced with the actual table alias."
  },
  {
    "objectID": "advanced-features.html#segments---reusable-filters",
    "href": "advanced-features.html#segments---reusable-filters",
    "title": "Advanced Features",
    "section": "",
    "text": "Define named filters that can be reused across queries:\nmodels:\n  - name: orders\n    table: orders\n    segments:\n      - name: completed\n        sql: \"{model}.status = 'completed'\"\n        description: \"Only completed orders\"\n\n      - name: high_value\n        sql: \"{model}.amount &gt; 100\"\n        description: \"High value orders\"\nUse in queries:\nsql = layer.compile(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.region\"],\n    segments=[\"orders.completed\", \"orders.high_value\"]\n)\nThe {model} placeholder gets replaced with the actual table alias."
  },
  {
    "objectID": "advanced-features.html#metric-level-filters",
    "href": "advanced-features.html#metric-level-filters",
    "title": "Advanced Features",
    "section": "Metric-Level Filters",
    "text": "Metric-Level Filters\nFilters that automatically apply whenever a metric is used:\nmetrics:\n  - name: completed_revenue\n    agg: sum\n    sql: amount\n    filters: [\"{model}.status = 'completed'\"]\nEvery query using completed_revenue will automatically filter to completed orders."
  },
  {
    "objectID": "advanced-features.html#jinja2-templating",
    "href": "advanced-features.html#jinja2-templating",
    "title": "Advanced Features",
    "section": "Jinja2 Templating",
    "text": "Jinja2 Templating\nUse full Jinja2 syntax in SQL fields:\nmetrics:\n  - name: taxed_revenue\n    agg: sum\n    sql: \"{% if include_tax %}amount * 1.1{% else %}amount{% endif %}\"\n# Use with parameters\nlayer.compile(\n    metrics=[\"orders.taxed_revenue\"],\n    parameters={\"include_tax\": True}\n)\nJinja2 supports: - Conditionals: {% if ... %}...{% endif %} - Loops: {% for item in items %}...{% endfor %} - Filters: { name | upper }"
  },
  {
    "objectID": "advanced-features.html#inheritance",
    "href": "advanced-features.html#inheritance",
    "title": "Advanced Features",
    "section": "Inheritance",
    "text": "Inheritance\n\nModel Inheritance\nExtend base models to reduce duplication:\nmodels:\n  - name: base_sales\n    table: sales\n    primary_key: sale_id\n    dimensions:\n      - name: date\n        type: time\n        granularity: day\n      - name: region\n        type: categorical\n\n  - name: filtered_sales\n    extends: base_sales  # Inherits all dimensions!\n    segments:\n      - name: completed\n        sql: \"{model}.status = 'completed'\"\n\n\nMetric Inheritance\nExtend base metrics:\nmetrics:\n  - name: base_revenue\n    agg: sum\n    sql: amount\n\n  - name: completed_revenue\n    extends: base_revenue\n    filters: [\"{model}.status = 'completed'\"]\nChild inherits all parent properties and can override or add to them."
  },
  {
    "objectID": "advanced-features.html#hierarchies-drill-down",
    "href": "advanced-features.html#hierarchies-drill-down",
    "title": "Advanced Features",
    "section": "Hierarchies & Drill-Down",
    "text": "Hierarchies & Drill-Down\nDefine hierarchical dimensions:\nfrom sidemantic import Dimension\n\n# Define hierarchy\ncountry = Dimension(name=\"country\", type=\"categorical\")\nstate = Dimension(name=\"state\", type=\"categorical\", parent=\"country\")\ncity = Dimension(name=\"city\", type=\"categorical\", parent=\"state\")\nNavigate the hierarchy:\n# Get full path\nmodel.get_hierarchy_path(\"city\")\n# Returns: ['country', 'state', 'city']\n\n# Drill down\nmodel.get_drill_down(\"country\")  # Returns: 'state'\nmodel.get_drill_down(\"state\")    # Returns: 'city'\n\n# Drill up\nmodel.get_drill_up(\"city\")    # Returns: 'state'\nmodel.get_drill_up(\"state\")   # Returns: 'country'"
  },
  {
    "objectID": "advanced-features.html#relative-date-ranges",
    "href": "advanced-features.html#relative-date-ranges",
    "title": "Advanced Features",
    "section": "Relative Date Ranges",
    "text": "Relative Date Ranges\nUse natural language for date filters:\nlayer.compile(\n    metrics=[\"orders.revenue\"],\n    filters=[\"orders_cte.created_at &gt;= 'last 7 days'\"]\n)\n# Auto-converts to: created_at &gt;= CURRENT_DATE - 7\nSupported expressions: - \"today\", \"yesterday\", \"tomorrow\" - \"last N days\", \"last N weeks\", \"last N months\" - \"this week\", \"last week\", \"next week\" - \"this month\", \"last month\", \"next month\" - \"this quarter\", \"last quarter\" - \"this year\", \"last year\""
  },
  {
    "objectID": "advanced-features.html#ungrouped-queries",
    "href": "advanced-features.html#ungrouped-queries",
    "title": "Advanced Features",
    "section": "Ungrouped Queries",
    "text": "Ungrouped Queries\nGet raw rows without aggregation (for detail views):\nsql = layer.compile(\n    metrics=[\"orders.revenue\"],\n    dimensions=[\"orders.customer_id\", \"orders.order_id\"],\n    ungrouped=True  # Returns raw rows\n)\nWithout ungrouped=True, you get aggregated results. With ungrouped=True, you get individual order rows."
  },
  {
    "objectID": "advanced-features.html#metadata-fields",
    "href": "advanced-features.html#metadata-fields",
    "title": "Advanced Features",
    "section": "Metadata Fields",
    "text": "Metadata Fields\n\nDisplay Formatting\nmetrics:\n  - name: revenue\n    agg: sum\n    sql: amount\n    format: \"$#,##0.00\"\n    value_format_name: \"usd\"\n\ndimensions:\n  - name: discount_rate\n    type: numeric\n    format: \"0.0%\"\n    value_format_name: \"percent\"\n\n\nDrill Fields\nDefine drill-down paths for BI tools:\nmetrics:\n  - name: revenue\n    agg: sum\n    sql: amount\n    drill_fields: [\"customer.name\", \"product.name\", \"order.date\"]\n\n\nNon-Additivity Markers\nMark metrics that can’t be summed across certain dimensions:\nmetrics:\n  - name: avg_order_value\n    agg: avg\n    sql: amount\n    non_additive_dimension: \"date\"  # Don't sum averages across time!\n\n\nDefault Dimensions\nSpecify default time dimension and granularity:\nmetrics:\n  - name: daily_revenue\n    agg: sum\n    sql: amount\n    default_time_dimension: \"order_date\"\n    default_grain: \"day\""
  },
  {
    "objectID": "examples.html#ratio-metrics",
    "href": "examples.html#ratio-metrics",
    "title": "Examples",
    "section": "Ratio Metrics",
    "text": "Ratio Metrics\n\nYAMLPython\n\n\nmetrics:\n  - name: completed_revenue\n    agg: sum\n    expr: amount\n    filters: [\"{model}.status = 'completed'\"]\n\n  - name: total_revenue\n    agg: sum\n    expr: amount\n\n  - name: completion_rate\n    type: ratio\n    numerator: completed_revenue\n    denominator: total_revenue\n\n\nMetric(name=\"completed_revenue\", agg=\"sum\", expr=\"amount\",\n       filters=[\"{model}.status = 'completed'\"]),\nMetric(name=\"total_revenue\", agg=\"sum\", expr=\"amount\"),\nMetric(name=\"completion_rate\", type=\"ratio\",\n       numerator=\"completed_revenue\", denominator=\"total_revenue\")\n\n\n\nlayer.sql(\"SELECT completion_rate FROM orders\")"
  },
  {
    "objectID": "examples.html#derived-metrics",
    "href": "examples.html#derived-metrics",
    "title": "Examples",
    "section": "Derived Metrics",
    "text": "Derived Metrics\n\nYAMLPython\n\n\nmetrics:\n  - name: revenue\n    agg: sum\n    expr: amount\n\n  - name: cost\n    agg: sum\n    expr: cost\n\n  - name: profit\n    type: derived\n    expr: \"revenue - cost\"\n\n  - name: margin\n    type: derived\n    expr: \"profit / revenue\"\n\n\nMetric(name=\"revenue\", agg=\"sum\", expr=\"amount\"),\nMetric(name=\"cost\", agg=\"sum\", expr=\"cost\"),\nMetric(name=\"profit\", type=\"derived\", expr=\"revenue - cost\"),\nMetric(name=\"margin\", type=\"derived\", expr=\"profit / revenue\")\n\n\n\nlayer.sql(\"SELECT revenue, profit, margin FROM orders\")"
  },
  {
    "objectID": "examples.html#segments-named-filters",
    "href": "examples.html#segments-named-filters",
    "title": "Examples",
    "section": "Segments (Named Filters)",
    "text": "Segments (Named Filters)\n\nYAMLPython\n\n\nmodels:\n  - name: orders\n    segments:\n      - name: completed\n        sql: \"{model}.status = 'completed'\"\n      - name: high_value\n        sql: \"{model}.amount &gt;= 500\"\n\n\nfrom sidemantic import Segment\n\norders = Model(\n    name=\"orders\",\n    segments=[\n        Segment(name=\"completed\", sql=\"{model}.status = 'completed'\"),\n        Segment(name=\"high_value\", sql=\"{model}.amount &gt;= 500\")\n    ]\n)\n\n\n\n# Use segments in queries\nlayer.compile(\n    metrics=[\"orders.revenue\"],\n    segments=[\"orders.completed\", \"orders.high_value\"]\n)"
  },
  {
    "objectID": "examples.html#metric-level-filters",
    "href": "examples.html#metric-level-filters",
    "title": "Examples",
    "section": "Metric-Level Filters",
    "text": "Metric-Level Filters\n\nYAMLPython\n\n\nmetrics:\n  - name: completed_revenue\n    agg: sum\n    expr: amount\n    filters:\n      - \"{model}.status = 'completed'\"\n\n\nMetric(\n    name=\"completed_revenue\",\n    agg=\"sum\",\n    expr=\"amount\",\n    filters=[\"{model}.status = 'completed'\"]\n)\n\n\n\nFilters are automatically applied in the WHERE clause whenever the metric is used."
  },
  {
    "objectID": "examples.html#relative-date-ranges",
    "href": "examples.html#relative-date-ranges",
    "title": "Examples",
    "section": "Relative Date Ranges",
    "text": "Relative Date Ranges\n# Use natural language date ranges in filters\nlayer.compile(\n    metrics=[\"orders.revenue\"],\n    filters=[\"orders.order_date &gt;= 'last 7 days'\"]\n)\n\n# Other examples:\n# - \"today\"\n# - \"yesterday\"\n# - \"last 30 days\"\n# - \"this week\"\n# - \"this month\"\n# - \"this quarter\"\n# - \"this year\""
  },
  {
    "objectID": "examples.html#hierarchies-drill-down",
    "href": "examples.html#hierarchies-drill-down",
    "title": "Examples",
    "section": "Hierarchies & Drill-Down",
    "text": "Hierarchies & Drill-Down\n\nYAMLPython\n\n\ndimensions:\n  - name: country\n    type: categorical\n    expr: country\n\n  - name: state\n    type: categorical\n    expr: state\n    parent: country\n\n  - name: city\n    type: categorical\n    expr: city\n    parent: state\n\n\nDimension(name=\"country\", type=\"categorical\", expr=\"country\"),\nDimension(name=\"state\", type=\"categorical\", expr=\"state\", parent=\"country\"),\nDimension(name=\"city\", type=\"categorical\", expr=\"city\", parent=\"state\")\n\n\n\n# Use drill-down API\nmodel.get_hierarchy_path(\"city\")  # ['country', 'state', 'city']\nmodel.get_drill_down(\"state\")     # 'city'\nmodel.get_drill_up(\"city\")        # 'state'"
  },
  {
    "objectID": "examples.html#inheritance",
    "href": "examples.html#inheritance",
    "title": "Examples",
    "section": "Inheritance",
    "text": "Inheritance\n\nYAMLPython\n\n\nmodels:\n  - name: base_orders\n    table: orders\n    dimensions:\n      - name: status\n        expr: status\n\n  - name: completed_orders\n    extends: base_orders\n    metrics:\n      - name: revenue\n        agg: sum\n        expr: amount\n\n\nbase = Model(\n    name=\"base_orders\",\n    table=\"orders\",\n    dimensions=[Dimension(name=\"status\", expr=\"status\")]\n)\n\nextended = Model(\n    name=\"completed_orders\",\n    extends=\"base_orders\",\n    metrics=[Metric(name=\"revenue\", agg=\"sum\", expr=\"amount\")]\n)\n\n\n\nChild models inherit all dimensions, metrics, and relationships from parent."
  },
  {
    "objectID": "examples.html#jinja2-templates",
    "href": "examples.html#jinja2-templates",
    "title": "Examples",
    "section": "Jinja2 Templates",
    "text": "Jinja2 Templates\n\nYAMLPython\n\n\nmetrics:\n  - name: filtered_revenue\n    agg: sum\n    expr: |\n      {% if include_tax %}\n        amount * 1.1\n      {% else %}\n        amount\n      {% endif %}\n\n\nMetric(\n    name=\"filtered_revenue\",\n    agg=\"sum\",\n    expr=\"\"\"\n    {% if include_tax %}\n        amount * 1.1\n    {% else %}\n        amount\n    {% endif %}\n    \"\"\"\n)\n\n\n\nlayer.compile(\n    metrics=[\"orders.filtered_revenue\"],\n    parameters={\"include_tax\": True}\n)"
  },
  {
    "objectID": "examples.html#ungrouped-queries",
    "href": "examples.html#ungrouped-queries",
    "title": "Examples",
    "section": "Ungrouped Queries",
    "text": "Ungrouped Queries\n# Get raw rows without aggregation\nlayer.compile(\n    metrics=[\"orders.revenue\"],  # Still available\n    dimensions=[\"orders.order_id\", \"orders.customer_id\"],\n    ungrouped=True  # No GROUP BY\n)"
  },
  {
    "objectID": "python-api.html#segment",
    "href": "python-api.html#segment",
    "title": "Python API",
    "section": "Segment",
    "text": "Segment\nDefine reusable named filters:\nfrom sidemantic import Segment\n\n# Simple segment\ncompleted = Segment(\n    name=\"completed\",\n    sql=\"{model}.status = 'completed'\",\n    description=\"Orders that have been completed\"\n)\n\n# Complex segment\nhigh_value_customers = Segment(\n    name=\"high_value\",\n    sql=\"{model}.lifetime_value &gt;= 10000 AND {model}.tier = 'premium'\",\n    public=True\n)\n\nProperties\n\nname: Unique segment name\nsql: SQL WHERE clause expression (use {model} placeholder)\ndescription: Human-readable description\npublic: Whether segment is visible in API/UI (default: True)"
  },
  {
    "objectID": "python-api.html#relative-date-ranges",
    "href": "python-api.html#relative-date-ranges",
    "title": "Python API",
    "section": "Relative Date Ranges",
    "text": "Relative Date Ranges\nUse natural language date expressions in filters:\n# Supported patterns:\n# - \"today\"\n# - \"yesterday\"\n# - \"last N days\" / \"last N day\"\n# - \"next N days\" / \"next N day\"\n# - \"this week\" / \"this month\" / \"this quarter\" / \"this year\"\n# - \"last week\" / \"last month\" / \"last quarter\" / \"last year\"\n\nlayer.compile(\n    metrics=[\"orders.revenue\"],\n    filters=[\"orders.order_date &gt;= 'last 7 days'\"]\n)"
  },
  {
    "objectID": "python-api.html#jinja2-templates",
    "href": "python-api.html#jinja2-templates",
    "title": "Python API",
    "section": "Jinja2 Templates",
    "text": "Jinja2 Templates\nUse Jinja2 templates in SQL expressions:\n# In metrics\nmetric = Metric(\n    name=\"revenue\",\n    agg=\"sum\",\n    expr=\"\"\"\n    {% if include_tax %}\n        amount * (1 + tax_rate)\n    {% else %}\n        amount\n    {% endif %}\n    \"\"\"\n)\n\n# In filters\nlayer.compile(\n    metrics=[\"orders.revenue\"],\n    filters=[\"orders.category = '{{ category }}'\"],\n    parameters={\"category\": \"electronics\", \"include_tax\": True}\n)\n\n# With loops\nmetric = Metric(\n    name=\"total\",\n    agg=\"sum\",\n    expr=\"\"\"\n    {% for field in fields %}\n        {{ field }}{% if not loop.last %} + {% endif %}\n    {% endfor %}\n    \"\"\"\n)"
  },
  {
    "objectID": "sql-queries.html#sql-support-overview",
    "href": "sql-queries.html#sql-support-overview",
    "title": "SQL Queries",
    "section": "SQL Support Overview",
    "text": "SQL Support Overview\n\n\n\nFeature\nSupported\nNotes\n\n\n\n\nSELECT\n✅ Yes\nMetrics and dimensions\n\n\nSELECT *\n✅ Yes\nExpands to all model fields\n\n\nWHERE\n✅ Yes\nStandard SQL conditions\n\n\nORDER BY\n✅ Yes\nSort by any field\n\n\nLIMIT / OFFSET\n✅ Yes\nPagination support\n\n\nParameters\n✅ Yes\n{ param } syntax\n\n\nCross-Model Queries\n✅ Yes\nAuto-joins via relationships\n\n\nJOIN\n❌ No\nJoins are automatic\n\n\nGROUP BY\n❌ No\nGrouping is automatic\n\n\nAggregate Functions\n❌ No\nUse pre-defined metrics\n\n\nHAVING\n❌ No\nUse WHERE on metrics instead\n\n\nSubqueries\n❌ No\nNot supported\n\n\nCTEs / WITH\n❌ No\nNot supported\n\n\nWindow Functions\n❌ No\nUse cumulative metrics\n\n\nDISTINCT\n❌ No\nDimensions are auto-distinct\n\n\nUNION / INTERSECT\n❌ No\nSet operations not supported\n\n\nINSERT / UPDATE / DELETE\n❌ No\nRead-only semantic layer"
  },
  {
    "objectID": "sql-queries.html#what-this-is-for",
    "href": "sql-queries.html#what-this-is-for",
    "title": "SQL Queries",
    "section": "What This Is For",
    "text": "What This Is For\nThe SQL interface lets you query pre-defined metrics and dimensions using familiar SQL syntax. You can filter, sort, and combine data across models - the semantic layer handles joins and aggregations automatically.\nGood for: - Exploring metrics across dimensions (SELECT revenue, status FROM orders WHERE region = 'US') - Building dashboards and reports with consistent metric definitions - Querying across related models without writing joins - Using parameters for dynamic filters (WHERE date &gt;= {{ start_date }})\nNot for: - Ad-hoc analytics with SUM(), COUNT(), or other aggregation functions - Complex SQL operations like subqueries, CTEs, or window functions - One-off queries that don’t fit your metric definitions\nIf you need ad-hoc SQL: Use layer.compile() to generate base SQL, then modify and execute it yourself."
  },
  {
    "objectID": "adapters.html",
    "href": "adapters.html",
    "title": "Format Adapters",
    "section": "",
    "text": "Sidemantic can import semantic models from other popular semantic layer formats, letting you use your existing metric definitions with Sidemantic’s query engine and features.\nExport support is in alpha - other formats don’t support all of Sidemantic’s features, so some capabilities may be lost when exporting."
  },
  {
    "objectID": "adapters.html#supported-formats",
    "href": "adapters.html#supported-formats",
    "title": "Format Adapters",
    "section": "Supported Formats",
    "text": "Supported Formats\n\n\n\n\n\n\n\n\n\nFormat\nImport\nExport\nNotes\n\n\n\n\nSidemantic (native)\n✅\n✅\nFull feature support\n\n\nCube\n✅\n✅*\nNo native segments\n\n\nMetricFlow (dbt)\n✅\n✅*\nNo native segments or hierarchies\n\n\nLookML (Looker)\n✅\n✅*\nLiquid templating (not Jinja)\n\n\nHex\n✅\n✅*\n⚠️ No segments or cross-model derived metrics\n\n\nRill\n✅\n✅*\n⚠️ No relationships, segments, or cross-model metrics; single-model only\n\n\nSuperset (Apache)\n✅\n✅*\nNo relationships in datasets\n\n\nOmni\n✅\n✅*\nRelationships in separate model file\n\n\nGoodData\n✅\n✅*\nFacts and attributes; MAQL metrics\n\n\n\n* Export is in alpha"
  },
  {
    "objectID": "adapters.html#feature-compatibility",
    "href": "adapters.html#feature-compatibility",
    "title": "Format Adapters",
    "section": "Feature Compatibility",
    "text": "Feature Compatibility\nThis table shows which Sidemantic features are preserved when importing/exporting to other formats:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFeature\nSidemantic\nCube\nMetricFlow\nLookML\nHex\nRill\nSuperset\nOmni\nGoodData\nNotes\n\n\n\n\nModels\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\nAll formats support models/tables\n\n\nDimensions\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\nAll formats support dimensions\n\n\nRelationships\n✅\n✅\n✅\n✅\n✅\n❌\n❌\n✅\n✅\nRill/Superset: single-model only; Omni: in model file; GoodData: references\n\n\nTime Dimensions\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\nAll formats support time dimensions with granularity\n\n\nSimple Metrics\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\nAll formats support sum, count, avg, min, max\n\n\nRatio Metrics\n✅\n✅\n✅\n✅\n✅\n⚠️\n⚠️\n✅\n✅\nRill/Superset: exported as derived metric with formula\n\n\nDerived Metrics\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\n✅\nAll formats support calculated metrics\n\n\nCumulative Metrics\n✅\n✅\n✅\n⚠️\n⚠️\n⚠️\n⚠️\n⚠️\n⚠️\nCube: rolling_window; others: exported as SQL/MAQL\n\n\nTime Comparison\n✅\n⚠️\n✅\n⚠️\n⚠️\n⚠️\n⚠️\n⚠️\n⚠️\nMetricFlow: native; others: exported as calculated measure\n\n\nSegments\n✅\n✅\n⚠️\n✅\n⚠️\n❌\n❌\n⚠️\n⚠️\nMetricFlow/Hex/Omni/GoodData: stored in meta; Rill/Superset: not supported\n\n\nMetric Filters\n✅\n✅\n⚠️\n✅\n✅\n⚠️\n❌\n✅\n✅\nMetricFlow: stored in meta; Rill: basic support; Superset: none; Omni/GoodData: native\n\n\nParameters\n✅\n❌\n❌\n❌\n❌\n❌\n❌\n❌\n❌\nSidemantic-only feature\n\n\nHierarchies\n✅\n⚠️\n⚠️\n⚠️\n⚠️\n❌\n❌\n⚠️\n⚠️\nCube/LookML/Omni: drill_fields; MetricFlow/Hex/GoodData: meta; Rill/Superset: none\n\n\nInheritance\n✅\n⚠️\n⚠️\n✅\n⚠️\n⚠️\n⚠️\n⚠️\n⚠️\nLookML: native extends; others: resolved before export\n\n\nJinja Templates\n✅\n✅\n✅\n⚠️\n✅\n✅\n✅\n✅\n❌\nLookML uses Liquid; GoodData uses MAQL\n\n\nMetadata Fields\n✅\n⚠️\n⚠️\n⚠️\n⚠️\n⚠️\n✅\n✅\n✅\nSuperset/Omni/GoodData: label support; others: label/description preserved\n\n\nUngrouped Queries\n✅\n❌\n❌\n❌\n❌\n❌\n❌\n❌\n❌\nSidemantic-only feature\n\n\n\nLegend:\n\n✅ Full support - feature works bidirectionally\n⚠️ Partial support - feature works with limitations\n❌ Not supported - feature lost on export\n🚧 Experimental - may have bugs or limitations\n\nImportant Notes:\n\nInheritance: When exporting models or metrics with extends, the adapter automatically resolves the inheritance chain and exports the fully merged result. The parent model/metric and the extends field are not included in the export - only the complete, merged definition.\nSegments & Hierarchies in MetricFlow: Since MetricFlow doesn’t have native support for these features, they’re stored in the meta field. They’re preserved on round-trip but won’t be used by MetricFlow’s query engine.\nMetadata Fields: Most metadata fields (format, drill_fields, etc.) are stored in meta fields for compatibility, but format is exported natively where supported."
  },
  {
    "objectID": "adapters.html#using-adapters",
    "href": "adapters.html#using-adapters",
    "title": "Format Adapters",
    "section": "Using Adapters",
    "text": "Using Adapters\n\nImport from Cube\nConvert Cube.js semantic models to Sidemantic:\nfrom sidemantic.adapters.cube import CubeAdapter\n\n# Import from Cube YAML\nadapter = CubeAdapter()\ngraph = adapter.parse(\"cube/schema/Orders.yml\")\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nImport from MetricFlow\nConvert dbt MetricFlow models to Sidemantic:\nfrom sidemantic.adapters.metricflow import MetricFlowAdapter\n\n# Import from MetricFlow YAML\nadapter = MetricFlowAdapter()\ngraph = adapter.parse(\"models/metrics/\")  # Directory of YAML files\n\n# Query with Sidemantic\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nExport to Cube\nConvert Sidemantic models to Cube format:\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.cube import CubeAdapter\n\n# Load Sidemantic model\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Export to Cube\nadapter = CubeAdapter()\nadapter.export(layer.graph, \"cube/schema/output.yml\")\n\n\nExport to MetricFlow\nConvert Sidemantic models to dbt MetricFlow:\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.metricflow import MetricFlowAdapter\n\n# Load Sidemantic model\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Export to MetricFlow\nadapter = MetricFlowAdapter()\nadapter.export(layer.graph, \"models/metrics/semantic_layer.yml\")\n\n\nImport from LookML\nConvert Looker LookML views to Sidemantic:\nfrom sidemantic.adapters.lookml import LookMLAdapter\n\n# Import from LookML\nadapter = LookMLAdapter()\ngraph = adapter.parse(\"views/orders.lkml\")  # Single file or directory\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nExport to LookML\nConvert Sidemantic models to LookML format:\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.lookml import LookMLAdapter\n\n# Load Sidemantic model\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Export to LookML\nadapter = LookMLAdapter()\nadapter.export(layer.graph, \"views/output.lkml\")\n\n\nImport from Hex\nConvert Hex semantic models to Sidemantic:\nfrom sidemantic.adapters.hex import HexAdapter\n\n# Import from Hex YAML\nadapter = HexAdapter()\ngraph = adapter.parse(\"hex/models/\")  # Directory of YAML files\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nExport to Hex\nConvert Sidemantic models to Hex format:\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.hex import HexAdapter\n\n# Load Sidemantic model\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Export to Hex (creates one file per model)\nadapter = HexAdapter()\nadapter.export(layer.graph, \"hex/models/\")\n\n\nImport from Rill\nConvert Rill metrics views to Sidemantic:\nfrom sidemantic.adapters.rill import RillAdapter\n\n# Import from Rill YAML\nadapter = RillAdapter()\ngraph = adapter.parse(\"rill/metrics/\")  # Directory of YAML files\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer()\nlayer.graph = graph\nresult = layer.compile(metrics=[\"orders.revenue\"])\n\n\nExport to Rill\nConvert Sidemantic models to Rill format:\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.rill import RillAdapter\n\n# Load Sidemantic model\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\n\n# Export to Rill (creates one metrics view per model)\nadapter = RillAdapter()\nadapter.export(layer.graph, \"rill/metrics/\")"
  },
  {
    "objectID": "adapters.html#migration-examples",
    "href": "adapters.html#migration-examples",
    "title": "Format Adapters",
    "section": "Migration Examples",
    "text": "Migration Examples\n\nCube → Sidemantic → MetricFlow\nMigrate from Cube to MetricFlow via Sidemantic:\nfrom sidemantic.adapters.cube import CubeAdapter\nfrom sidemantic.adapters.metricflow import MetricFlowAdapter\n\n# Import from Cube\ncube_adapter = CubeAdapter()\ngraph = cube_adapter.parse(\"cube/schema/\")\n\n# Export to MetricFlow\nmf_adapter = MetricFlowAdapter()\nmf_adapter.export(graph, \"models/metrics/converted.yml\")\n\n\nMetricFlow → Sidemantic (with enhancements)\nImport MetricFlow and add Sidemantic-specific features:\nfrom sidemantic.adapters.metricflow import MetricFlowAdapter\nfrom sidemantic import SemanticLayer, Segment\n\n# Import from MetricFlow\nadapter = MetricFlowAdapter()\ngraph = adapter.parse(\"models/metrics/\")\n\n# Add Sidemantic features\nlayer = SemanticLayer(graph=graph)\n\n# Add segments (not in MetricFlow)\norders = layer.graph.get_model(\"orders\")\norders.segments.extend([\n    Segment(name=\"completed\", sql=\"{model}.status = 'completed'\"),\n    Segment(name=\"high_value\", sql=\"{model}.amount &gt;= 500\")\n])\n\n# Save enhanced model\nlayer.to_yaml(\"semantic_layer.yml\")"
  },
  {
    "objectID": "adapters.html#format-specific-notes",
    "href": "adapters.html#format-specific-notes",
    "title": "Format Adapters",
    "section": "Format-Specific Notes",
    "text": "Format-Specific Notes\n\nCube\nStrengths: - Simple, JavaScript-friendly syntax - Good for basic aggregations and joins - Strong SQL generation\nLimitations: - No native support for ratio or cumulative metrics - Limited time comparison capabilities - Relationships must use explicit join definitions\nConversion Notes: - Cube cubes → Sidemantic models - Cube dimensions → Sidemantic dimensions - Cube measures → Sidemantic metrics - Cube joins → Sidemantic relationships (inferred)\n\n\nMetricFlow (dbt)\nStrengths: - Comprehensive metric type support - Native time comparisons and cumulative metrics - Entity-based relationship model - Jinja template support\nLimitations: - dbt-specific configuration requirements - More verbose YAML syntax - Requires dbt context for some features\nConversion Notes: - MetricFlow semantic_models → Sidemantic models - MetricFlow entities → Inferred relationships - MetricFlow dimensions → Sidemantic dimensions - MetricFlow measures → Sidemantic metrics (model-level) - MetricFlow metrics → Sidemantic metrics (graph-level)"
  },
  {
    "objectID": "adapters.html#round-trip-guarantees",
    "href": "adapters.html#round-trip-guarantees",
    "title": "Format Adapters",
    "section": "Round-Trip Guarantees",
    "text": "Round-Trip Guarantees\n\nLossless Round-Trips\nThese conversions preserve all information:\n\nSidemantic → Sidemantic: Perfect round-trip (native format)\n\n\n\nLossy Round-Trips\nThese conversions lose some information:\n\nSidemantic → Cube → Sidemantic: Loses segments, cumulative metrics, time comparisons\nSidemantic → MetricFlow → Sidemantic: Loses segments, ungrouped query support, hierarchies\nAny format → Sidemantic: May lose format-specific metadata\n\nBest Practice: Keep your source of truth in one format and export to others as needed. Don’t round-trip unless necessary."
  },
  {
    "objectID": "adapters.html#validating-conversions",
    "href": "adapters.html#validating-conversions",
    "title": "Format Adapters",
    "section": "Validating Conversions",
    "text": "Validating Conversions\nAlways validate after import/export:\n# Import\ngraph = adapter.parse(\"source.yml\")\n\n# Verify models loaded\nprint(f\"Loaded {len(graph.models)} models\")\nfor name, model in graph.models.items():\n    print(f\"  {name}: {len(model.metrics)} metrics, {len(model.dimensions)} dimensions\")\n\n# Verify metrics\nprint(f\"Loaded {len(graph.metrics)} graph-level metrics\")\n\n# Test query\nlayer = SemanticLayer(graph=graph)\nsql = layer.compile(metrics=[\"orders.revenue\"])\nprint(\"Generated SQL:\", sql)\n\n# Export and compare\nadapter.export(graph, \"output.yml\")\ngraph2 = adapter.parse(\"output.yml\")\nassert len(graph.models) == len(graph2.models)"
  },
  {
    "objectID": "adapters.html#getting-help",
    "href": "adapters.html#getting-help",
    "title": "Format Adapters",
    "section": "Getting Help",
    "text": "Getting Help\nIf you encounter issues with format conversion:\n\nCheck the compatibility table for known limitations\nValidate your source format is correctly structured\nTest with a simple model first before converting complex definitions\nFile an issue at github.com/sidequery/sidemantic with:\n\nSource format and file\nExpected vs actual behavior\nGenerated SQL or error messages"
  },
  {
    "objectID": "adapters.html#contributing-adapters",
    "href": "adapters.html#contributing-adapters",
    "title": "Format Adapters",
    "section": "Contributing Adapters",
    "text": "Contributing Adapters\nWant to add support for another format? See our adapter development guide or file a feature request.\nPopular formats we’d like to support: - Malloy - Google’s semantic modeling language - Omni - Modern BI semantic layer - GoodData - Enterprise analytics platform - AtScale - Semantic layer for data warehouses - Apache Superset - Open-source BI semantic layer"
  },
  {
    "objectID": "adapters.html#conversion-quirks",
    "href": "adapters.html#conversion-quirks",
    "title": "Format Adapters",
    "section": "Conversion Quirks",
    "text": "Conversion Quirks\n\nCube\nImport (Cube → Sidemantic):\n\ncubes → models\ndimensions → dimensions\nmeasures → metrics\njoins → relationships (inferred from join definitions)\n${CUBE} placeholder → {model} placeholder\nsegments → segments (native support)\nCalculated measures (type=number) → derived metrics\nrolling_window → cumulative metrics\n\nExport (Sidemantic → Cube):\n\nRatio metrics → calculated measures with division SQL\nCumulative metrics → measures with rolling_window\nSegments → native segment definitions\nHierarchies → drill_members arrays\nInheritance is resolved before export (fully merged definitions)\n\n\n\nMetricFlow\nImport (MetricFlow → Sidemantic):\n\nsemantic_models → models\nentities → inferred relationships\ndimensions → dimensions\nmeasures → model-level metrics\nmetrics (graph-level) → graph-level metrics\nSegments/hierarchies from meta field → preserved\n\nExport (Sidemantic → MetricFlow):\n\nSegments → stored in meta (no native support)\nHierarchies → stored in dimension meta\nInheritance info in meta then stripped (definitions fully resolved)\nRelationships → entities with foreign keys\n\n\n\nLookML\nImport (LookML → Sidemantic):\n\nviews → models\ndimensions → dimensions\ndimension_group → multiple time dimensions (one per timeframe)\nmeasures → metrics\nfilters (view-level) → segments\nderived_table → model with SQL\n${TABLE} placeholder → {model} placeholder\nMeasure filters parsed from filters__all\n\nExport (Sidemantic → LookML):\n\nMultiple time dimensions with same base name → single dimension_group with multiple timeframes\nSegments → view-level filters\nRatio/derived metrics → type=number measures\n{model} placeholder → ${TABLE} placeholder\n\n\n\nHex\nImport (Hex → Sidemantic):\n\nModel id and base_sql_table/base_sql_query → models\ndimensions with expr_sql or expr_calc → dimensions\nmeasures with func/func_sql/func_calc → metrics\nrelations with join_sql → relationships\nMeasure filters (inline or referenced) → metric filters\nunique: true dimensions → primary key detection\ntimestamp_tz/timestamp_naive/date types → time dimensions\n\nExport (Sidemantic → Hex):\n\nEach model → separate YAML file\nTime dimensions → specific type variants (date vs timestamp_tz)\nRatio/derived metrics → func_sql\nSegments not directly supported (can use measure filters)\n${interpolation} references preserved where possible\n\n\n\nRill\nImport (Rill → Sidemantic):\n\nmetrics_view (type) → models\ndimensions with column/expression → dimensions\nmeasures with expression → metrics\ntimeseries column → time dimension\nsmallest_time_grain → time dimension granularity\nDerived measures (type: derived) → derived metrics\nSimple aggregation expressions parsed with sqlglot\n\nExport (Sidemantic → Rill):\n\nEach model → separate metrics view YAML file\ntable reference → model or table field (based on naming)\nTime dimensions → timeseries and smallest_time_grain\nAggregation functions reconstructed from agg + sql fields\nDerived metrics → type: derived measures\nRelationships not exported (Rill focuses on single-model views)\nSegments not exported (use measure filters instead)"
  },
  {
    "objectID": "adapters.html#round-trip-considerations",
    "href": "adapters.html#round-trip-considerations",
    "title": "Format Adapters",
    "section": "Round-Trip Considerations",
    "text": "Round-Trip Considerations\nThese conversions lose some information:\n\nSidemantic → Cube → Sidemantic: Loses segments, cumulative metrics, time comparisons\nSidemantic → MetricFlow → Sidemantic: Loses segments, ungrouped query support, hierarchies\nSidemantic → LookML → Sidemantic: Loses relationship details (views don’t declare joins)\nSidemantic → Hex → Sidemantic: Loses segment support\nSidemantic → Rill → Sidemantic: Loses relationships, segments, hierarchies\nSidemantic → Superset → Sidemantic: Loses relationships, segments, metric filters, hierarchies\nSidemantic → Omni → Sidemantic: Loses segments, some field reference complexity\nSidemantic → GoodData → Sidemantic: Loses segments, metrics stored separately (not in datasets)\nAny format → Sidemantic: May lose format-specific metadata\n\nKeep your source of truth in one format and export to others as needed. Don’t round-trip unless necessary."
  },
  {
    "objectID": "adapters.html#importing-into-sidemantic",
    "href": "adapters.html#importing-into-sidemantic",
    "title": "Format Adapters",
    "section": "Importing into Sidemantic",
    "text": "Importing into Sidemantic\n\nFrom Cube\nRead Cube.js semantic models into Sidemantic:\nfrom sidemantic.adapters.cube import CubeAdapter\n\n# Import from Cube YAML\nadapter = CubeAdapter()\ngraph = adapter.parse(\"cube/schema/Orders.yml\")\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nFrom MetricFlow\nRead dbt MetricFlow models into Sidemantic:\nfrom sidemantic.adapters.metricflow import MetricFlowAdapter\n\n# Import from MetricFlow YAML\nadapter = MetricFlowAdapter()\ngraph = adapter.parse(\"models/metrics/\")  # Directory of YAML files\n\n# Query with Sidemantic\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nFrom LookML\nRead Looker LookML views into Sidemantic:\nfrom sidemantic.adapters.lookml import LookMLAdapter\n\n# Import from LookML\nadapter = LookMLAdapter()\ngraph = adapter.parse(\"views/orders.lkml\")  # Single file or directory\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nFrom Hex\nRead Hex semantic models into Sidemantic:\nfrom sidemantic.adapters.hex import HexAdapter\n\n# Import from Hex YAML\nadapter = HexAdapter()\ngraph = adapter.parse(\"hex/models/\")  # Directory of YAML files\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT revenue FROM orders\")\n\n\nFrom Rill\nRead Rill metrics views into Sidemantic:\nfrom sidemantic.adapters.rill import RillAdapter\n\n# Import from Rill YAML\nadapter = RillAdapter()\ngraph = adapter.parse(\"rill/metrics/\")  # Directory of YAML files\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer()\nlayer.graph = graph\nresult = layer.compile(metrics=[\"orders.revenue\"])\n\n\nFrom Superset\nRead Apache Superset datasets into Sidemantic:\nfrom sidemantic.adapters.superset import SupersetAdapter\n\n# Import from Superset YAML\nadapter = SupersetAdapter()\ngraph = adapter.parse(\"superset/datasets/\")  # Directory of YAML files\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT total_revenue FROM orders\")\n\n\nFrom Omni\nRead Omni Analytics views into Sidemantic:\nfrom sidemantic.adapters.omni import OmniAdapter\n\n# Import from Omni YAML views\nadapter = OmniAdapter()\ngraph = adapter.parse(\"omni/\")  # Directory with views/ subdirectory and model.yaml\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT total_revenue FROM orders\")\n\n\nFrom GoodData\nRead GoodData datasets into Sidemantic:\nfrom sidemantic.adapters.gooddata import GoodDataAdapter\n\n# Import from GoodData YAML datasets\nadapter = GoodDataAdapter()\ngraph = adapter.parse(\"gooddata/\")  # Directory of YAML files\n\n# Query with Sidemantic\nfrom sidemantic import SemanticLayer\nlayer = SemanticLayer(graph=graph)\nresult = layer.sql(\"SELECT total_revenue FROM orders\")"
  },
  {
    "objectID": "adapters.html#exporting-from-sidemantic-alpha",
    "href": "adapters.html#exporting-from-sidemantic-alpha",
    "title": "Format Adapters",
    "section": "Exporting from Sidemantic (Alpha)",
    "text": "Exporting from Sidemantic (Alpha)\nExport support is experimental. Some features may be lost or simplified when exporting to other formats.\n\nTo Cube\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.cube import CubeAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = CubeAdapter()\nadapter.export(layer.graph, \"cube/schema/output.yml\")\n\n\nTo MetricFlow\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.metricflow import MetricFlowAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = MetricFlowAdapter()\nadapter.export(layer.graph, \"models/metrics/semantic_layer.yml\")\n\n\nTo LookML\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.lookml import LookMLAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = LookMLAdapter()\nadapter.export(layer.graph, \"views/output.lkml\")\n\n\nTo Hex\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.hex import HexAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = HexAdapter()\nadapter.export(layer.graph, \"hex/models/\")  # Creates one file per model\n\n\nTo Rill\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.rill import RillAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = RillAdapter()\nadapter.export(layer.graph, \"rill/metrics/\")  # Creates one metrics view per model\n\n\nTo Superset\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.superset import SupersetAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = SupersetAdapter()\nadapter.export(layer.graph, \"superset/datasets/\")  # Creates one dataset per model\n\n\nTo Omni\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.omni import OmniAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = OmniAdapter()\nadapter.export(layer.graph, \"omni/\")  # Creates views/ directory and model.yaml\n\n\nTo GoodData\nfrom sidemantic import SemanticLayer\nfrom sidemantic.adapters.gooddata import GoodDataAdapter\n\nlayer = SemanticLayer.from_yaml(\"semantic_layer.yml\")\nadapter = GoodDataAdapter()\nadapter.export(layer.graph, \"gooddata/\")  # Creates dataset YAML files"
  },
  {
    "objectID": "adapters.html#conversion-notes",
    "href": "adapters.html#conversion-notes",
    "title": "Format Adapters",
    "section": "Conversion Notes",
    "text": "Conversion Notes\n\nCube\nImport (Cube → Sidemantic):\n\ncubes → models\ndimensions → dimensions\nmeasures → metrics\njoins → relationships (inferred from join definitions)\n${CUBE} placeholder → {model} placeholder\nsegments → segments (native support)\nCalculated measures (type=number) → derived metrics\nrolling_window → cumulative metrics\n\nExport (Sidemantic → Cube):\n\nRatio metrics → calculated measures with division SQL\nCumulative metrics → measures with rolling_window\nSegments → native segment definitions\nHierarchies → drill_members arrays\nInheritance is resolved before export (fully merged definitions)\n\n\n\nMetricFlow\nImport (MetricFlow → Sidemantic):\n\nsemantic_models → models\nentities → inferred relationships\ndimensions → dimensions\nmeasures → model-level metrics\nmetrics (graph-level) → graph-level metrics\nSegments/hierarchies from meta field → preserved\n\nExport (Sidemantic → MetricFlow):\n\nSegments → stored in meta (no native support)\nHierarchies → stored in dimension meta\nInheritance info in meta then stripped (definitions fully resolved)\nRelationships → entities with foreign keys\n\n\n\nLookML\nImport (LookML → Sidemantic):\n\nviews → models\nexplores → relationships (parsed from join definitions)\ndimensions → dimensions\ndimension_group → multiple time dimensions (one per timeframe)\nmeasures → metrics\nfilters (view-level) → segments\nderived_table → model with SQL\n${TABLE} placeholder → {model} placeholder\nMeasure filters parsed from filters__all\nForeign keys extracted from sql_on in explore joins\n\nExport (Sidemantic → LookML):\n\nMultiple time dimensions with same base name → single dimension_group with multiple timeframes\nSegments → view-level filters\nRatio/derived metrics → type=number measures\n{model} placeholder → ${TABLE} placeholder\n\n\n\nHex\nImport (Hex → Sidemantic):\n\nModel id and base_sql_table/base_sql_query → models\ndimensions with expr_sql or expr_calc → dimensions\nmeasures with func/func_sql/func_calc → metrics\nrelations with join_sql → relationships\nMeasure filters (inline or referenced) → metric filters\nunique: true dimensions → primary key detection\ntimestamp_tz/timestamp_naive/date types → time dimensions\n\nExport (Sidemantic → Hex):\n\nEach model → separate YAML file\nTime dimensions → specific type variants (date vs timestamp_tz)\nRatio/derived metrics → func_sql\nSegments not directly supported (can use measure filters)\n${interpolation} references preserved where possible\n\n\n\nRill\nImport (Rill → Sidemantic):\n\nmetrics_view (type) → models\ndimensions with column/expression → dimensions\nmeasures with expression → metrics\ntimeseries column → time dimension\nsmallest_time_grain → time dimension granularity\nDerived measures (type: derived) → derived metrics\nSimple aggregation expressions parsed with sqlglot\n\nExport (Sidemantic → Rill):\n\nEach model → separate metrics view YAML file\ntable reference → model or table field (based on naming)\nTime dimensions → timeseries and smallest_time_grain\nAggregation functions reconstructed from agg + sql fields\nDerived metrics → type: derived measures\nRelationships not exported (Rill focuses on single-model views)\nSegments not exported (use measure filters instead)\n\n\n\nSuperset\nImport (Superset → Sidemantic):\n\ntable_name → model name\nschema + table_name → model table\nsql → model sql (for virtual datasets)\ncolumns → dimensions\nmetrics → model metrics\nmain_dttm_col → time dimension detection\nverbose_name → label field\nis_dttm flag → time dimension type\nmetric_type → aggregation mapping (count, sum, avg, etc.)\n\nExport (Sidemantic → Superset):\n\nEach model → separate dataset YAML file\nModel name + table → schema and table_name\nModel sql → virtual dataset with SQL query\nDimensions → columns with is_dttm, groupby, filterable flags\nTime dimensions → main_dttm_col reference\nMetrics → measures with metric_type and expression\nLabel → verbose_name field\nRatio/derived metrics → calculated measures with expression\nRelationships not exported (datasets are single-model)\nSegments not exported (no native support)\nMetric filters not exported (no native support)\n\n\n\nOmni\nImport (Omni → Sidemantic):\n\nname (view) → model name\nschema + table_name → model table\nsql → model sql (for SQL-based views)\ndimensions → dimensions\nmeasures with aggregate_type → metrics\ntimeframes → time dimension granularity\nlabel → model description (if no description field)\n${TABLE} placeholder → {model} placeholder\n${view.field} references → simplified field references\nMeasure filters → metric filters\nrelationships (from model.yaml) → model relationships\n\nExport (Sidemantic → Omni):\n\nEach model → separate view YAML file in views/ directory\nModel name + table → schema and table_name\nModel sql → view-level sql field\nModel description → view label\nDimensions → dimension fields with type and sql\nTime dimensions → timeframes array based on granularity\nMetrics → measures with aggregate_type\nMetric aggregations → aggregate_type (sum, count, average, etc.)\nMetric filters → measure filters (field: {is: value} format)\n{model} placeholder → ${TABLE} placeholder\nRelationships → exported to separate model.yaml file with join_from_view, join_to_view, on_sql\nSegments not directly supported (stored in meta if needed)\n\n\n\nGoodData\nImport (GoodData → Sidemantic):\n\nid (dataset) → model name\ntable_path → model table\nsql → model sql (for SQL-based datasets)\nfields with type: fact → numeric dimensions\nfields with type: attribute → categorical/time dimensions\nAttribute labels → additional dimensions\ndata_type: DATE → time dimension\nprimary_key → model primary key\nreferences → model relationships\nMAQL metrics (from separate files) → metrics\nMAQL SELECT SUM({fact/name}) → aggregation extraction\nMAQL WHERE {label/field}=\"value\" → metric filters\n\nExport (Sidemantic → GoodData):\n\nEach model → separate dataset YAML file\nModel name → dataset id\nModel description → dataset title\nModel table → table_path\nModel sql → dataset sql\nNumeric dimensions → type: fact fields\nCategorical/time dimensions → type: attribute fields\nTime dimensions → data_type: DATE\nRelationships → references array\nMetrics exported as MAQL expressions (not included in dataset files by default)\nAggregations → MAQL format: SELECT SUM({fact/field})\nMetric filters → MAQL WHERE clause with {label/field}=“value”\nSegments not directly supported (stored in meta if needed)"
  }
]