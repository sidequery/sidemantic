---
title: "Interactive Demo"
filters:
  - marimo
---

Try the semantic layer interactively with real data.

```{.marimo}
import marimo as mo
import duckdb
from sidemantic import SemanticLayer, Model, Dimension, Measure, Join, Parameter
from datetime import datetime, timedelta
import pandas as pd

# Setup database with sample data
conn = duckdb.connect(":memory:")

# Create tables
conn.execute("""
    CREATE TABLE orders (
        id INTEGER,
        customer_id INTEGER,
        status VARCHAR,
        order_date DATE,
        amount DECIMAL(10, 2)
    )
""")

conn.execute("""
    INSERT INTO orders VALUES
        (1, 1, 'completed', '2024-01-15', 250.00),
        (2, 1, 'completed', '2024-02-10', 180.00),
        (3, 2, 'pending', '2024-02-15', 320.00),
        (4, 2, 'completed', '2024-03-01', 410.00),
        (5, 3, 'completed', '2024-03-10', 190.00),
        (6, 3, 'cancelled', '2024-03-15', 75.00),
        (7, 1, 'completed', '2024-04-01', 290.00),
        (8, 2, 'completed', '2024-04-15', 350.00)
""")

conn.execute("""
    CREATE TABLE customers (
        id INTEGER,
        name VARCHAR,
        region VARCHAR,
        tier VARCHAR
    )
""")

conn.execute("""
    INSERT INTO customers VALUES
        (1, 'Alice', 'US', 'premium'),
        (2, 'Bob', 'EU', 'standard'),
        (3, 'Charlie', 'US', 'premium')
""")

# Create semantic layer
layer = SemanticLayer(connection="duckdb:///:memory:")

# Copy data to layer's connection
layer.conn = conn

# Define models
orders = Model(
    name="orders",
    table="orders",
    primary_key="id",
    dimensions=[
        Dimension(name="status", type="categorical", sql="status"),
        Dimension(name="order_date", type="time", sql="order_date", granularity="day")
    ],
    measures=[
        Measure(name="revenue", agg="sum", expr="amount"),
        Measure(name="order_count", agg="count"),
        Measure(name="avg_order_value", agg="avg", expr="amount")
    ],
    joins=[
        Join(name="customers", type="belongs_to", foreign_key="customer_id")
    ]
)

customers = Model(
    name="customers",
    table="customers",
    primary_key="id",
    dimensions=[
        Dimension(name="region", type="categorical", sql="region"),
        Dimension(name="tier", type="categorical", sql="tier")
    ],
    measures=[
        Measure(name="customer_count", agg="count")
    ]
)

layer.add_model(orders)
layer.add_model(customers)

mo.md("## Semantic Layer Interactive Demo")
```

```{.marimo}
# Filters
status_select = mo.ui.dropdown(
    options=["all", "completed", "pending", "cancelled"],
    value="all",
    label="Order Status"
)

region_select = mo.ui.dropdown(
    options=["all", "US", "EU"],
    value="all",
    label="Region"
)

mo.hstack([status_select, region_select])
```

```{.marimo}
# Build filters
filters = []

if status_select.value != "all":
    filters.append(f"orders.status = '{status_select.value}'")

# Only add region filter if we're selecting customers dimension too
include_region = region_select.value != "all"

mo.md(f"**Active Filters:** {', '.join(filters) if filters else 'None'}")
```

```{.marimo}
# Query metrics
if include_region and region_select.value != "all":
    # Include customers dimension and filter
    filters_with_region = filters + [f"customers.region = '{region_select.value}'"]

    result = layer.query(
        metrics=["orders.revenue", "orders.order_count", "orders.avg_order_value"],
        dimensions=["customers.region"],
        filters=filters_with_region
    )
else:
    # Orders only
    result = layer.query(
        metrics=["orders.revenue", "orders.order_count", "orders.avg_order_value"],
        dimensions=[],
        filters=filters
    )

df = result.fetchdf()

mo.md(f"""
## Key Metrics

**Total Revenue:** ${df['revenue'].sum():,.2f}

**Order Count:** {df['order_count'].sum():,.0f}

**Avg Order Value:** ${df['avg_order_value'].mean():,.2f}
""")
```

```{.marimo}
# Revenue by status
status_result = layer.query(
    metrics=["orders.revenue", "orders.order_count"],
    dimensions=["orders.status"],
    filters=filters if not include_region else filters + [f"customers.region = '{region_select.value}'"] if region_select.value != "all" else filters
)

status_df = status_result.fetchdf()

mo.ui.table(status_df)
```

```{.marimo}
# Show generated SQL
sql = layer.compile(
    metrics=["orders.revenue", "orders.order_count"],
    dimensions=["orders.status"],
    filters=filters
)

mo.md(f"""
## Generated SQL

```sql
{sql}
```
""")
```

```{.marimo}
mo.md("""
## Try Your Own Query

Write SQL directly against the semantic layer:
""")
```

```{.marimo}
query_input = mo.ui.text_area(
    value="SELECT revenue, status FROM orders WHERE status = 'completed'",
    label="SQL Query"
)

query_input
```

```{.marimo}
# Execute custom query
try:
    custom_result = layer.sql(query_input.value)
    custom_df = custom_result.fetchdf()

    mo.ui.table(custom_df)
except Exception as e:
    mo.md(f"**Error:** {str(e)}")
```

```{.marimo}
mo.md("""
## What Just Happened?

- **Automatic Joins**: When you filter by region, the semantic layer automatically joins orders â†’ customers
- **Consistent Metrics**: Revenue is always calculated the same way
- **SQL Rewriting**: Your simple SQL gets rewritten to use proper aggregations and joins

Try changing the filters or writing your own queries above!
""")
```
