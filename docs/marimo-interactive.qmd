---
title: "Interactive Tour"
page-layout: article
description: "Interactive Sidemantic demo: define models and joins, compile metrics to SQL, run in DuckDB, filter across models, and view an ER diagram generated from the semantic graph."
filters:
  - marimo-team/marimo
pyproject: |
  requires-python = ">=3.11"
  dependencies = [
      "marimo>=0.16.5",
      "sidemantic==0.2.4",
      "duckdb>=1.0",
      "sqlglot>=25",
      "pydantic>=2",
      "altair>=5",
      "numpy",
  ]
---

Use Sidemantic's semantic layer directly in the browser. This demo:

- Defines semantic models (orders, customers, region_map) with dimensions and metrics (including ratio metric `return_rate`).
- Uses reusable segments (named filters) and metric-level filters that auto-apply in WHERE clauses.
- Declares relationships (`many_to_one`, `one_to_many`) with automatic join-path discovery for multi-hop queries (e.g., region_group × tier).
- Compiles metrics + dimensions + filters to SQL (DuckDB dialect) via the Sidemantic SQL generator.
- Applies global filters (status, region, category, tier) that propagate across models; period-to-date metrics are computed by filtering time.
- Shows an ER diagram generated from the semantic graph to explain relationships.

```python {.marimo name="deps"}
import micropip
try:
    import sidemantic  # type: ignore
except ModuleNotFoundError:
    await micropip.install(["sidemantic==0.2.4"], deps=False)
    import sidemantic  # type: ignore
```

```python {.marimo}
import marimo as mo
```

```python {.marimo}
import altair as alt
import duckdb

mo.md("# Sidemantic Interactive Demo")
conn = duckdb.connect(":memory:")

N = 20000
sql_create_orders = f"""
CREATE OR REPLACE TABLE orders AS
SELECT
  range AS id,
  1 + CAST(random()*500 AS INTEGER) AS customer_id,
  CASE
    WHEN random() < 0.50 THEN 'completed'
    WHEN random() < 0.70 THEN 'shipped'
    WHEN random() < 0.85 THEN 'pending'
    WHEN random() < 0.95 THEN 'cancelled'
    ELSE 'returned'
  END AS status,
  (DATE '2024-01-01' + CAST(random()*365 AS INTEGER)) AS order_date,
  ROUND((random()*600)+10,2) AS amount,
  CASE WHEN random() < 0.50 THEN 'US' WHEN random() < 0.80 THEN 'EU' ELSE 'APAC' END AS region,
  CASE
    WHEN random() < 0.22 THEN 'electronics'
    WHEN random() < 0.40 THEN 'apparel'
    WHEN random() < 0.60 THEN 'home'
    WHEN random() < 0.75 THEN 'toys'
    WHEN random() < 0.88 THEN 'beauty'
    ELSE 'outdoors'
  END AS category
FROM range(1, {N});
"""
conn.execute(sql_create_orders)

conn.execute("""
ALTER TABLE orders ADD COLUMN order_month DATE;
UPDATE orders SET order_month = DATE_TRUNC('month', order_date);
ALTER TABLE orders ADD COLUMN cost DOUBLE;
ALTER TABLE orders ADD COLUMN profit DOUBLE;
UPDATE orders SET cost = ROUND(amount * (0.55 + random()*0.30), 2);
UPDATE orders SET profit = ROUND(amount - cost, 2);
""")

conn.execute("""
CREATE OR REPLACE TABLE customers AS
SELECT
  range AS id,
  CASE WHEN random() < 0.30 THEN 'premium' ELSE 'standard' END AS tier,
  CASE WHEN random() < 0.50 THEN 'US' WHEN random() < 0.80 THEN 'EU' ELSE 'APAC' END AS region
FROM range(1, 501);
""")

conn.execute("""
CREATE OR REPLACE TABLE region_map(region VARCHAR, region_group VARCHAR);
INSERT INTO region_map VALUES ('US','Americas'), ('EU','Europe'), ('APAC','Asia Pacific');
""")
```

```python {.marimo}
# Controls (multiselects)
status_opts = [r[0] for r in conn.execute("SELECT DISTINCT status FROM orders ORDER BY 1").fetchall()]
region_opts = [r[0] for r in conn.execute("SELECT DISTINCT region FROM orders ORDER BY 1").fetchall()]
category_opts = [r[0] for r in conn.execute("SELECT DISTINCT category FROM orders ORDER BY 1").fetchall()]
tier_opts = [r[0] for r in conn.execute("SELECT DISTINCT tier FROM customers ORDER BY 1").fetchall()]

status_select = mo.ui.multiselect(options=status_opts, value=[], label="Status")
region_select = mo.ui.multiselect(options=region_opts, value=[], label="Region")
category_select = mo.ui.multiselect(options=category_opts, value=[], label="Category")
tier_select = mo.ui.multiselect(options=tier_opts, value=[], label="Tier")
month_options = [r[0] for r in conn.execute("SELECT DISTINCT strftime(order_month, '%Y-%m') AS ym FROM orders ORDER BY ym").fetchall()]
month_select = mo.ui.dropdown(options=month_options, value=month_options[-1], label="Month for *_TD")

# Render all controls together so they show reliably
mo.vstack([
    mo.md('<div style="height:12px"></div>'),
    mo.hstack([status_select, region_select, category_select]),
    mo.hstack([tier_select, month_select]),
    mo.md('<div style="height:12px"></div>'),
])
```

```python {.marimo}
# Build a minimal semantic model with Sidemantic (compile SQL and execute in DuckDB)
from importlib import import_module
Model = import_module("sidemantic.core.model").Model
Dimension = import_module("sidemantic.core.dimension").Dimension
Metric = import_module("sidemantic.core.metric").Metric
Relationship = import_module("sidemantic.core.relationship").Relationship
Segment = import_module("sidemantic.core.segment").Segment
SemanticGraph = import_module("sidemantic.core.semantic_graph").SemanticGraph
SQLGenerator = import_module("sidemantic.sql.generator_v2").SQLGenerator

graph = SemanticGraph()

orders_model = Model(
    name="orders",
    table="orders",
    primary_key="id",
    dimensions=[
        Dimension(name="status", type="categorical", expr="status"),
        Dimension(name="order_date", type="time", expr="order_date", granularity="day"),
        Dimension(name="region", type="categorical", expr="region"),
        Dimension(name="category", type="categorical", expr="category"),
    ],
    metrics=[
        Metric(name="revenue", agg="sum", expr="amount"),
        Metric(name="order_count", agg="count"),
        Metric(name="avg_order_value", agg="avg", expr="amount"),
        Metric(name="cost", agg="sum", expr="cost"),
        Metric(name="profit", agg="sum", expr="profit"),
        # Metric with filter (auto-applied in WHERE clause)
        Metric(name="returns", agg="count", filters=["{model}.status = 'returned'"]),
        # Ratio metric
        Metric(name="return_rate", type="ratio", numerator="orders.returns", denominator="orders.order_count"),
    ],
    segments=[
        Segment(name="completed", sql="{model}.status = 'completed'"),
        Segment(name="high_value", sql="{model}.amount >= 300"),
    ],
    relationships=[Relationship(name="customers", type="many_to_one", foreign_key="customer_id")],
)

customers_model = Model(
    name="customers",
    table="customers",
    primary_key="id",
    dimensions=[
        Dimension(name="tier", type="categorical", expr="tier"),
        Dimension(name="region", type="categorical", expr="region"),
    ],
    relationships=[Relationship(name="region_map", type="many_to_one", foreign_key="region", primary_key="region")],
)

region_map_model = Model(
    name="region_map",
    table="region_map",
    primary_key="region",
    dimensions=[Dimension(name="region_group", type="categorical", expr="region_group")],
)

graph.add_model(orders_model)
graph.add_model(customers_model)
graph.add_model(region_map_model)

generator = SQLGenerator(graph, dialect="duckdb")
```

```python {.marimo}
# Helpers: build Sidemantic filters and run compiled SQL in DuckDB
def build_filters():
    f = []
    if status_select.value:
        vals = ",".join(["'" + v.replace("'", "''") + "'" for v in status_select.value])
        f.append(f"orders.status IN ({vals})")
    if region_select.value:
        vals = ",".join(["'" + v.replace("'", "''") + "'" for v in region_select.value])
        f.append(f"orders.region IN ({vals})")
    if category_select.value:
        vals = ",".join(["'" + v.replace("'", "''") + "'" for v in category_select.value])
        f.append(f"orders.category IN ({vals})")
    if tier_select.value:
        vals = ",".join(["'" + v.replace("'", "''") + "'" for v in tier_select.value])
        f.append(f"customers.tier IN ({vals})")
    return f

# Token that captures UI state so downstream cells re-execute when filters change
FILTERS_STATE = (
    tuple(status_select.value),
    tuple(region_select.value),
    tuple(category_select.value),
    tuple(tier_select.value),
    month_select.value,
)

def run_query(metrics, dims, order_by=None, limit=None, extra_filters=None, _state: object | None = None):
    # _state is unused inside; it exists to make marimo track dependencies on UI
    filters = build_filters()
    if extra_filters:
        filters = filters + list(extra_filters)
    dims_sql = list(dims)
    injected = False
    # Force-join customers when tier filter is active to satisfy generator's model discovery
    if tier_select.value and not any(d.startswith("customers.") for d in dims_sql):
        dims_sql.append("customers.tier")
        injected = True

    sql = generator.generate(metrics=metrics, dimensions=dims_sql, filters=filters, order_by=order_by, limit=limit)
    cur = conn.execute(sql)
    rows = cur.fetchall()
    cols = [d[0] for d in cur.description]
    data = [dict(zip(cols, r)) for r in rows]
    # Drop injected column if the caller didn't request it explicitly
    if injected and data and "tier" in data[0] and not any(d.endswith("tier") or d.endswith(".tier") for d in dims):
        for rec in data:
            rec.pop("tier", None)
    return data, sql
RUN_QUERY_READY = True
```


```python {.marimo}
# KPIs via Sidemantic → DuckDB (two-column layout)
import datetime as _dt

kpi_rows, _ = run_query(
    metrics=["orders.revenue", "orders.order_count", "orders.avg_order_value"],
    dims=[], _state=FILTERS_STATE,
)

revenue = float(kpi_rows[0].get("revenue", 0.0)) if kpi_rows else 0.0
orders  = int(kpi_rows[0].get("order_count", 0)) if kpi_rows else 0
aov     = float(kpi_rows[0].get("avg_order_value", 0.0)) if kpi_rows else 0.0

sel_month = month_select.value  # 'YYYY-MM'
_y, _m = map(int, sel_month.split('-'))
_month_start = _dt.date(_y, _m, 1).isoformat()
_q_start_month = ((_m - 1)//3)*3 + 1
_q_start = _dt.date(_y, _q_start_month, 1).isoformat()
_y_start = _dt.date(_y, 1, 1).isoformat()

# Compute period-to-date by filtering period via SQL, still using the same metric
mtd_rows, _ = run_query(
    metrics=["orders.revenue"], dims=[],
    extra_filters=[f"DATE_TRUNC('month', orders.order_date) = DATE '{_month_start}'"], _state=FILTERS_STATE
)
mtd = float(mtd_rows[0].get("revenue", 0.0)) if mtd_rows else 0.0

qtd_rows, _ = run_query(
    metrics=["orders.revenue"], dims=[],
    extra_filters=[f"DATE_TRUNC('quarter', orders.order_date) = DATE '{_q_start}'"], _state=FILTERS_STATE
)
qtd = float(qtd_rows[0].get("revenue", 0.0)) if qtd_rows else 0.0

ytd_rows, _ = run_query(
    metrics=["orders.revenue"], dims=[],
    extra_filters=[f"DATE_TRUNC('year', orders.order_date) = DATE '{_y_start}'"], _state=FILTERS_STATE
)
ytd = float(ytd_rows[0].get("revenue", 0.0)) if ytd_rows else 0.0

left_metrics = mo.md(f"""
**Revenue:** ${revenue:,.2f}
**Orders:** {orders}
**AOV:** ${aov:,.2f}
""")

ptd_metrics = mo.md(f"""
**MTD Revenue:** ${mtd:,.2f}
**QTD Revenue:** ${qtd:,.2f}
**YTD Revenue:** ${ytd:,.2f}
""")

left_col = mo.vstack([mo.md('### Key Metrics'), left_metrics])
right_col = mo.vstack([mo.md(f'### Period-to-date ({sel_month})'), ptd_metrics])

mo.vstack([
    mo.hstack([left_col, right_col]),
    mo.md('<div style="height:8px"></div>'),
])
```

```python {.marimo}
# Revenue by month
data, sql_month = run_query(metrics=["orders.revenue"], dims=["orders.order_date__month", "orders.status"], order_by=["orders.order_date__month"], _state=FILTERS_STATE)
chart_month = (
    alt.Chart(alt.Data(values=data))
    .mark_bar()
    .encode(
        x=alt.X("order_date__month:T", title="Month"),
        y=alt.Y("revenue:Q", title="Revenue"),
        color=alt.Color("status:N"),
        tooltip=["order_date__month:T", "status:N", alt.Tooltip("revenue:Q", title="Revenue")],
    )
)
mo.vstack([
    mo.md('### Revenue by Month'),
    mo.ui.altair_chart(chart_month),
    mo.md('<div style="height:16px"></div>'),
])

# Revenue by category (top 10)
top_cat_df, _ = run_query(metrics=["orders.revenue"], dims=["orders.category"], order_by=["revenue DESC"], limit=10, _state=FILTERS_STATE)
chart_cat = (
    alt.Chart(alt.Data(values=top_cat_df))
    .mark_bar()
    .encode(
        x=alt.X("revenue:Q", title="Revenue"),
        y=alt.Y("category:N", sort='-x', title="Category"),
        tooltip=["category:N", alt.Tooltip("revenue:Q", title="Revenue")],
    )
)
mo.vstack([
    mo.md('### Top Categories by Revenue'),
    mo.ui.altair_chart(chart_cat),
    mo.md('<div style="height:16px"></div>'),
])

# Avg order value by region over time
chart_aov_region = (
    alt.Chart(alt.Data(values=run_query(metrics=["orders.avg_order_value"], dims=["orders.region", "orders.order_date__month"], order_by=["orders.order_date__month"], _state=FILTERS_STATE)[0]))
    .mark_line()
    .encode(
        x=alt.X("order_date__month:T", title="Month"),
        y=alt.Y("avg_order_value:Q", title="Avg Order Value"),
        color=alt.Color("region:N"),
        tooltip=["order_date__month:T", "region:N", alt.Tooltip("avg_order_value:Q", title="AOV")],
    )
)
mo.vstack([
    mo.md('### Avg Order Value by Region Over Time'),
    mo.ui.altair_chart(chart_aov_region),
    mo.md('<div style="height:16px"></div>'),
])

# Revenue by region
chart_region = (
    alt.Chart(alt.Data(values=run_query(metrics=["orders.revenue"], dims=["orders.region"], order_by=["revenue DESC"], _state=FILTERS_STATE)[0]))
    .mark_bar()
    .encode(
        x=alt.X("region:N", sort='-y', title="Region"),
        y=alt.Y("revenue:Q", title="Revenue"),
        color=alt.Color("region:N"),
        tooltip=["region:N", alt.Tooltip("revenue:Q", title="Revenue")],
    )
)
mo.vstack([
    mo.md('### Revenue by Region'),
    mo.ui.altair_chart(chart_region),
    mo.md('<div style="height:16px"></div>'),
])

# Revenue heatmap (month x category)
chart_heat = (
    alt.Chart(alt.Data(values=run_query(metrics=["orders.revenue"], dims=["orders.order_date__month", "orders.category"], order_by=["orders.order_date__month"], _state=FILTERS_STATE)[0]))
    .mark_rect()
    .encode(
        x=alt.X("order_date__month:T", title="Month"),
        y=alt.Y("category:N", title="Category"),
        color=alt.Color("revenue:Q", title="Revenue"),
    )
)
mo.vstack([
    mo.md('### Revenue Heatmap (Month × Category)'),
    mo.ui.altair_chart(chart_heat),
    mo.md('<div style="height:16px"></div>'),
])
```

```python {.marimo}
# Multi-hop join demo via Sidemantic
join_df, _ = run_query(metrics=["orders.revenue"], dims=["region_map.region_group", "customers.tier"], order_by=["revenue DESC"], _state=FILTERS_STATE)
chart_join = (
    alt.Chart(alt.Data(values=join_df))
    .mark_bar()
    .encode(
        x=alt.X("region_group:N", title="Region Group"),
        y=alt.Y("revenue:Q", title="Revenue"),
        color=alt.Color("tier:N"),
        tooltip=["region_group:N", "tier:N", alt.Tooltip("revenue:Q", title="Revenue")],
    )
)
mo.vstack([
    mo.md('### Revenue by Region Group × Tier'),
    mo.ui.altair_chart(chart_join),
    mo.md('<div style="height:16px"></div>'),
])

# Top customers (via Sidemantic)
top_cust_df, _ = run_query(metrics=["orders.revenue"], dims=["orders.customer_id"], order_by=["revenue DESC"], limit=20, _state=FILTERS_STATE)
mo.vstack([
    mo.md('### Top Customers by Revenue'),
    mo.ui.table(top_cust_df),
    mo.md('<div style="height:16px"></div>'),
])

```


```python {.marimo}
# Detailed rows (filtered) — aggregated by date/status/region/category
detail_df, _ = run_query(
    metrics=["orders.revenue", "orders.order_count"],
    dims=["orders.order_date__day", "orders.status", "orders.region", "orders.category"],
    order_by=["orders.order_date__day"], _state=FILTERS_STATE,
)
mo.vstack([
    mo.md('### Detailed Rows'),
    mo.ui.table(detail_df),
    mo.md('<div style="height:16px"></div>'),
])
```

```python {.marimo}
# Interactive Query (SQL)
# Build query from semantic selections, edit SQL, and run

mo.md("### Interactive Query")

# Build metric and dimension options from the semantic graph
_metric_opts = []
for _mname, _model in graph.models.items():
    for _me in _model.metrics:
        _metric_opts.append(f"{_mname}.{_me.name}")
_metric_opts = sorted(set(_metric_opts))

_dim_opts = []
for _mname, _model in graph.models.items():
    for _d in _model.dimensions:
        if getattr(_d, "type", "") == "time":
            for _g in ("day", "month", "quarter", "year"):
                _dim_opts.append(f"{_mname}.{_d.name}__{_g}")
        _dim_opts.append(f"{_mname}.{_d.name}")
_dim_opts = sorted(set(_dim_opts))

iq_metrics = mo.ui.multiselect(options=_metric_opts, value=["orders.revenue"], label="Metrics")
iq_dims = mo.ui.multiselect(options=_dim_opts, value=["orders.order_date__month"], label="Dimensions")
iq_limit = mo.ui.number(value=50, label="Limit")
iq_compile = mo.ui.button(label="Compile SQL")
iq_run = mo.ui.button(label="Run SQL")
iq_sql = mo.ui.code_editor(value="-- Click Compile SQL to generate from selections", language="sql", min_height=180)
iq_results = mo.ui.table([])

mo.vstack([
    mo.hstack([iq_metrics, iq_dims, iq_limit]),
    mo.hstack([iq_compile, iq_run]),
    iq_sql,
    iq_results,
])
```

```python {.marimo}
# Interactive Query actions (separate from UI creation)
if iq_compile.value:
    try:
        sel_metrics = list(iq_metrics.value) or ["orders.revenue"]
        sel_dims = list(iq_dims.value) or []
        row_limit = int(iq_limit.value or 50)
        sql_text = generator.generate(metrics=sel_metrics, dimensions=sel_dims, filters=build_filters(), order_by=sel_dims or None, limit=row_limit)
        iq_sql.value = sql_text
    except Exception as e:
        iq_sql.value = f"-- Error compiling SQL: {e}"

if iq_run.value:
    try:
        to_run = (iq_sql.value or "").strip()
        if to_run:
            cur = conn.execute(to_run)
            cols = [d[0] for d in cur.description]
            rows = [dict(zip(cols, r)) for r in cur.fetchall()]
            iq_results.value = rows
    except Exception as e:
        iq_results.value = [{"error": str(e)}]
```

```python {.marimo}
# Data Model
python_src = """
from sidemantic.core.model import Model
from sidemantic.core.dimension import Dimension
from sidemantic.core.metric import Metric
from sidemantic.core.relationship import Relationship
from sidemantic.core.segment import Segment
from sidemantic.core.semantic_graph import SemanticGraph
from sidemantic.sql.generator_v2 import SQLGenerator

graph = SemanticGraph()

orders_model = Model(
    name="orders",
    table="orders",
    primary_key="id",
    dimensions=[
        Dimension(name="status", type="categorical", expr="status"),
        Dimension(name="order_date", type="time", expr="order_date", granularity="day"),
        Dimension(name="region", type="categorical", expr="region"),
        Dimension(name="category", type="categorical", expr="category"),
    ],
    metrics=[
        Metric(name="revenue", agg="sum", expr="amount"),
        Metric(name="order_count", agg="count"),
        Metric(name="avg_order_value", agg="avg", expr="amount"),
        Metric(name="cost", agg="sum", expr="cost"),
        Metric(name="profit", agg="sum", expr="profit"),
        Metric(name="returns", agg="count", filters=["{model}.status = 'returned'"]),
        Metric(name="return_rate", type="ratio", numerator="orders.returns", denominator="orders.order_count"),
    ],
    segments=[
        Segment(name="completed", sql="{model}.status = 'completed'"),
        Segment(name="high_value", sql="{model}.amount >= 300"),
    ],
    relationships=[Relationship(name="customers", type="many_to_one", foreign_key="customer_id")],
)

customers_model = Model(
    name="customers",
    table="customers",
    primary_key="id",
    dimensions=[
        Dimension(name="tier", type="categorical", expr="tier"),
        Dimension(name="region", type="categorical", expr="region"),
    ],
    relationships=[Relationship(name="region_map", type="many_to_one", foreign_key="region", primary_key="region")],
)

region_map_model = Model(
    name="region_map",
    table="region_map",
    primary_key="region",
    dimensions=[Dimension(name="region_group", type="categorical", expr="region_group")],
)

graph.add_model(orders_model)
graph.add_model(customers_model)
graph.add_model(region_map_model)

generator = SQLGenerator(graph, dialect="duckdb")
"""
```

```python {.marimo}
yaml_src = """
models:
  - name: orders
    table: orders
    primary_key: id
    dimensions:
      - name: status
        type: categorical
        expr: status
      - name: order_date
        type: time
        expr: order_date
        granularity: day
      - name: region
        type: categorical
        expr: region
      - name: category
        type: categorical
        expr: category
    metrics:
      - name: revenue
        agg: sum
        expr: amount
      - name: order_count
        agg: count
      - name: avg_order_value
        agg: avg
        expr: amount
      - name: cost
        agg: sum
        expr: cost
      - name: profit
        agg: sum
        expr: profit
      - name: returns
        agg: count
        filters:
          - "{model}.status = 'returned'"
      - name: return_rate
        type: ratio
        numerator: orders.returns
        denominator: orders.order_count
    segments:
      - name: completed
        sql: "{model}.status = 'completed'"
      - name: high_value
        sql: "{model}.amount >= 300"
    relationships:
      - name: customers
        type: many_to_one
        foreign_key: customer_id
  - name: customers
    table: customers
    primary_key: id
    dimensions:
      - name: tier
        type: categorical
        expr: tier
      - name: region
        type: categorical
        expr: region
    relationships:
      - name: region_map
        type: many_to_one
        foreign_key: region
        primary_key: region
  - name: region_map
    table: region_map
    primary_key: region
    dimensions:
      - name: region_group
        type: categorical
        expr: region_group
"""
```

```python {.marimo}
# Data Model (code + ER diagram)
mo.vstack([
    mo.md('## Data Model'),
    mo.md('### Python Definition'),
    mo.ui.code_editor(value=python_src, language='python', disabled=True, min_height=360),
    mo.md('### YAML Definition'),
    mo.ui.code_editor(value=yaml_src, language='yaml', disabled=True, min_height=420),
])
```

```python {.marimo}
# Mermaid ER diagram from Sidemantic graph
def _build_er_mermaid(g):
    lines = ["erDiagram"]

    # Entities with a handful of fields
    for m_name, m in g.models.items():
        # Base entity with primary key + dimensions only
        base_attrs = []
        pk = m.primary_key or "id"
        base_attrs.append(f"  string {pk} PK")
        for d in m.dimensions[:6]:
            if getattr(d, "type", "") == "time":
                dtype = "date"
            elif getattr(d, "type", "") in ("number", "numeric"):
                dtype = "number"
            else:
                dtype = "string"
            base_attrs.append(f"  {dtype} {d.name}")
        lines.append(f"{m_name} {{")
        lines.extend(base_attrs)
        lines.append("}")

        # Separate <model>_metrics entity listing all metrics
        metrics_list = m.metrics[:8]
        if metrics_list:
            metric_attrs = [f"  metric {me.name}" for me in metrics_list]
            metrics_entity = f"{m_name}_metrics"
            lines.append(f"{metrics_entity} {{")
            lines.extend(metric_attrs)
            lines.append("}")
            # One-to-one conceptual link from model to its metrics definition
            lines.append(f"{m_name} ||--|| {metrics_entity} : metrics")

    # Relationships
    for m_name, m in g.models.items():
        for rel in m.relationships:
            src = m_name
            dst = rel.name
            if rel.type == "many_to_one":
                card = "}o--||"  # many-to-one (child to parent)
            elif rel.type == "one_to_many":
                card = "||--o{"  # one-to-many (parent to child)
            elif rel.type == "one_to_one":
                card = "||--||"  # one-to-one
            else:
                card = "||--||"
            # Build a compact, single-token label to avoid Mermaid parsing issues
            l_fk = rel.sql_expr.replace(".", "_")
            r_pk = (rel.related_key or "id").replace(".", "_")
            label = f"{src}_{l_fk}_to_{dst}_{r_pk}"
            lines.append(f"{src} {card} {dst} : {label}")

    return "\n".join(lines)

er_diagram = _build_er_mermaid(graph)
mo.vstack([
    mo.md('### Data Model (ER Diagram)'),
    mo.mermaid(er_diagram),
])
```
