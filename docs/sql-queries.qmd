---
title: "SQL Queries"
---

Query the semantic layer with familiar SQL syntax.

## What This Is For

The SQL interface lets you query pre-defined metrics and dimensions using familiar SQL syntax. You can filter, sort, and combine data across models - the semantic layer handles joins and aggregations automatically.

**Good for:**
- Exploring metrics across dimensions (`SELECT revenue, status FROM orders WHERE region = 'US'`)
- Building dashboards and reports with consistent metric definitions
- Querying across related models without writing joins
- Using parameters for dynamic filters (`WHERE date >= {{ start_date }}`)

**Not for:**
- Ad-hoc analytics with `SUM()`, `COUNT()`, or other aggregation functions (use pre-defined metrics)
- Complex SQL operations like window functions
- One-off queries that don't fit your metric definitions

**If you need ad-hoc SQL:** Use `layer.compile()` to generate base SQL, then modify and execute it yourself. You can also use CTEs or subqueries to query semantic layer results and then apply additional transformations.

## SQL Support Overview

| Feature | Supported | Notes |
|---------|-----------|-------|
| **[SELECT](#select)** | ✅ Yes | Metrics and dimensions |
| **[SELECT *](#select-1)** | ✅ Yes | Expands to all model fields |
| **[WHERE](#where)** | ✅ Yes | Standard SQL conditions |
| **[ORDER BY](#order-by)** | ✅ Yes | Sort by any field |
| **[LIMIT / OFFSET](#limit-offset)** | ✅ Yes | Pagination support |
| **[Parameters](#parameters)** | ✅ Yes | `{{ param }}` syntax |
| **[Cross-Model Queries](#cross-model-queries)** | ✅ Yes | Auto-joins via relationships |
| **[JOIN](#no-explicit-joins)** | ❌ No | Joins are automatic |
| **[GROUP BY](#no-group-by)** | ❌ No | Grouping is automatic |
| **[Aggregate Functions](#no-aggregate-functions)** | ❌ No | Use pre-defined metrics |
| **[HAVING](#no-having)** | ❌ No | Use WHERE on metrics instead |
| **[Subqueries](#subqueries)** | ✅ Yes | Query semantic layer in subqueries |
| **[CTEs / WITH](#ctes-common-table-expressions)** | ✅ Yes | Use CTEs with semantic queries |
| **[Window Functions](#no-window-functions)** | ❌ No | Use cumulative metrics |
| **[DISTINCT](#no-distinct)** | ❌ No | Dimensions are auto-distinct |
| **[UNION / INTERSECT](#no-unionintersectexcept)** | ❌ No | Set operations not supported |
| **[INSERT / UPDATE / DELETE](#no-insertupdatedelete)** | ❌ No | Read-only semantic layer |

## Basic Queries

```python
layer.sql("SELECT revenue FROM orders")

layer.sql("""
    SELECT revenue, status
    FROM orders
    WHERE status = 'completed'
""")
```

## Supported Features

### SELECT

Select measures and dimensions:

```sql
SELECT revenue, order_count, status
FROM orders
```

Table prefixes optional (inferred from FROM):

```sql
-- Both work
SELECT orders.revenue FROM orders
SELECT revenue FROM orders
```

::: {.callout-note}
## FROM Clause References Model Names

The FROM clause uses **semantic model names**, not underlying table names:

```python
Model(name="orders", table="raw_orders_staging", ...)
```

```sql
SELECT revenue FROM orders  -- ✅ Use model name
SELECT revenue FROM raw_orders_staging  -- ❌ Not the table name
```
:::

### WHERE

Filter with standard SQL conditions:

```sql
SELECT revenue
FROM orders
WHERE status = 'completed'
  AND order_date >= '2024-01-01'
  AND amount > 100
```

### ORDER BY

```sql
SELECT revenue, status
FROM orders
ORDER BY revenue DESC, status ASC
```

### LIMIT / OFFSET

```sql
SELECT revenue FROM orders LIMIT 10

SELECT revenue FROM orders LIMIT 10 OFFSET 5
```

### Cross-Model Queries

Reference multiple models - joins happen automatically:

```sql
SELECT
    orders.revenue,
    customers.region,
    regions.country
FROM orders
```

### SELECT *

Expands to all dimensions and measures:

```sql
SELECT * FROM orders
-- Expands to all dimensions + measures in orders model
```

## Parameters

Use `{{ param }}` syntax:

```python
layer.sql(
    """
    SELECT revenue
    FROM orders
    WHERE order_date >= {{ start_date }}
      AND region = {{ region }}
    """,
    parameters={
        "start_date": "2024-01-01",
        "region": "US"
    }
)
```

::: {.callout-warning}
## Don't Quote Parameters
Parameters are automatically quoted based on type:
- ❌ `WHERE date >= '{{ start_date }}'` (creates `''2024-01-01''`)
- ✅ `WHERE date >= {{ start_date }}`
:::

## Limitations

These SQL features are **NOT supported**:

### No Explicit JOINs

❌ Can't write explicit JOIN syntax:
```sql
SELECT orders.revenue, customers.name
FROM orders
JOIN customers ON orders.customer_id = customers.id
```
This will raise an error: `Explicit JOIN syntax is not supported`

✅ Instead, reference both models:
```sql
-- Joins happen automatically based on model relationships
SELECT orders.revenue, customers.name
FROM orders
```

### No GROUP BY

❌ Can't write:
```sql
SELECT status, SUM(amount)
FROM orders
GROUP BY status
```

✅ Instead:
```sql
-- Grouping is automatic based on dimensions
SELECT revenue, status
FROM orders
```

### No Aggregate Functions

❌ Can't write:
```sql
SELECT COUNT(*), SUM(amount)
FROM orders
```

✅ Instead, define measures:
```yaml
metrics:
  - name: order_count
    agg: count
  - name: revenue
    agg: sum
    sql: amount
```

Then:
```sql
SELECT order_count, revenue FROM orders
```

### Subqueries

✅ You can use semantic layer queries in subqueries:
```sql
SELECT * FROM (
    SELECT revenue, status FROM orders
) AS orders_agg
WHERE revenue > 1000
```

This queries the semantic layer (which handles aggregation), then applies additional filtering in the outer query.

```sql
-- Join semantic query results with regular tables
SELECT
    orders_agg.revenue,
    orders_agg.region,
    r.continent
FROM (
    SELECT orders.revenue, customers.region
    FROM orders
) AS orders_agg
JOIN regions r ON orders_agg.region = r.region
```

### CTEs (Common Table Expressions)

✅ You can use CTEs with semantic layer queries:
```sql
WITH orders_by_region AS (
    SELECT revenue, status, customers.region
    FROM orders
)
SELECT * FROM orders_by_region
WHERE revenue > 500
ORDER BY revenue DESC
```

Mix semantic and regular CTEs:
```sql
WITH
    -- Semantic layer query
    orders_agg AS (
        SELECT revenue, status FROM orders
    ),
    -- Regular SQL
    status_labels AS (
        SELECT 'completed' as code, 'Complete' as label
        UNION ALL SELECT 'pending', 'Pending'
    )
SELECT
    o.revenue,
    s.label
FROM orders_agg o
JOIN status_labels s ON o.status = s.code
```

::: {.callout-tip}
## When to Use CTEs/Subqueries

Use CTEs and subqueries when you need to:
- Apply additional filtering/transformations after semantic layer aggregation
- Join semantic layer results with regular tables
- Build complex queries in readable steps
- Reuse semantic query results multiple times
:::

### No HAVING

❌ Can't write:
```sql
SELECT status, revenue
FROM orders
HAVING revenue > 1000
```

✅ Use WHERE on measures instead:
```sql
SELECT status, revenue
FROM orders
WHERE revenue > 1000  -- This works!
```

### No Window Functions

❌ Can't write:
```sql
SELECT revenue, ROW_NUMBER() OVER (PARTITION BY status)
FROM orders
```

✅ Use table calculations or cumulative measures instead.

### No DISTINCT

❌ Can't write:
```sql
SELECT DISTINCT status FROM orders
```

✅ Just select the dimension:
```sql
SELECT status FROM orders
```

### No UNION/INTERSECT/EXCEPT

❌ Set operations not supported.

### No INSERT/UPDATE/DELETE

Read-only semantic layer.

## Why These Limitations?

The semantic layer rewrites your SQL to use pre-defined measures and handle joins automatically. This means:

1. **Measures must be pre-defined** - No ad-hoc `SUM()` in SELECT
2. **Joins are automatic** - Based on model relationships
3. **Grouping is automatic** - Based on dimensions selected

This trade-off ensures:
- ✅ Consistent metric definitions
- ✅ Automatic join handling
- ✅ Symmetric aggregate deduplication
- ✅ Centralized business logic

## Best Practices

::: {.callout-tip}
## Define Once, Query Anywhere
Define metrics in YAML:
```yaml
metrics:
  - name: revenue
    agg: sum
    sql: amount
```

Then query with simple SQL:
```sql
SELECT revenue FROM orders
```
:::

::: {.callout-tip}
## Complex Logic in Measures
Put complex logic in measure definitions, not queries:

```yaml
# Define complex measure
metrics:
  - name: high_value_revenue
    agg: sum
    sql: "CASE WHEN amount > 1000 THEN amount ELSE 0 END"
```

```sql
-- Simple query
SELECT high_value_revenue FROM orders
```
:::

::: {.callout-tip}
## Filtering on Joined Tables

Joins happen automatically when you filter on related models:

```sql
-- This works! Automatically joins to customers
SELECT orders.revenue
WHERE customers.region = 'US'
```

You don't need to select a dimension from the filtered table - the filter alone triggers the join.
:::

## Programmatic Alternative

For full flexibility, use the programmatic API:

```python
result = layer.query(
    metrics=["orders.revenue"],
    dimensions=["orders.status"],
    filters=["orders.status = 'completed'"],
    order_by=["orders.revenue DESC"],
    limit=10
)
```

Or generate SQL and execute yourself:

```python
sql = layer.compile(
    metrics=["orders.revenue"],
    dimensions=["orders.status"]
)

# Modify as needed
sql += " UNION SELECT ..."

# Execute directly
conn.execute(sql)
```
